{"version":3,"sources":["Constants.ts","systems/PhysicsSystem.ts","systems/CameraMovementSystem.ts","systems/BlockGenerationSystem.ts","systems/BlockRenderSystem.ts","systems/PlayerMovementSystem.ts","systems/PlayerRenderSystem.ts","systems/BlockRemovalSystem.ts","AssetManager.ts","PlayerState.ts","systems/BackgroundRenderSystem.ts","systems/SmokeRenderSystem.ts","index.tsx"],"names":["Constants","CAMERA_WIDTH","CAMERA_HEIGHT","GAP","GRAVITY","PLAYER_WIDTH","PLAYER_HEIGHT","PLAYER_SCALE","JUMP_FORCE","RUN_FORCE","BLOCK_SIZE","BLOCK_BLOCK_SIZE","BLOCK_OFFSET_Y","PhysicsSystem","Inject","this","physicsWorld","Step","world","delta","System","CameraMovementSystem","camPos","viewport","getCamera","getPosition","setPosition","playerPos","x","y","BlockGenerationSystem","generatedStep","w","h","type","bodyDef","b2BodyDef","b2BodyType","b2_staticBody","position","Set","body","CreateBody","SetUserData","shape","b2PolygonShape","SetAsBox","CreateFixture","blocks","push","generateBlocks","currentStep","Math","floor","offsetX","random","createBox","BlockRenderSystem","batch","whiteTex","atlas","regions","createBatch","gl","createWhiteTexture","assetManager","getAtlas","findRegions","setProjection","combined","begin","box","draw","end","PlayerMovementSystem","playerBody","stunnedDuration","pressed","jumpLeft","gameOver","zeroCenter","runImpulse","jumpImpulse","b2_dynamicBody","fixedRotation","b2CircleShape","sensorShape","fixDef","b2FixtureDef","isSensor","userData","sensorShape2","fixDef2","ContactListener","movementSystem","movementSytem","contact","otherFixture","fixA","GetFixtureA","fixB","GetFixtureB","IsSensor","GetUserData","GetBody","playerState","changeAction","GetLinearVelocity","ApplyLinearImpulse","processJumpable","processObstacle","b2ContactListener","SetContactListener","v","inputHandler","isTouched","bodyPos","GetPosition","set","eventEmitter","emit","PlayerRenderSystem","animations","animationFrameDuration","run","jump","doubleJump","hurt","action","state","animName","frameDuration","frames","slice","length","createAnimation","process","playMode","PlayMode","LOOP","NORMAL","getAnimation","getKeyFrame","stateTime","BlockRemovalSystem","i","block","DestroyBody","splice","AssetManager","promises","atlases","Map","textures","done","path","promise","loadAtlas","then","get","loadTexture","Promise","all","PlayerState","BackgroundRenderSystem","map","s","getTexture","bg","drawHeight","drawWidth","height","width","offset","fixedCamera","drawBackground","drawCloud1","drawCloud2","drawCity1","drawCity2","city","cloud","gap","SmokeRenderSystem","a","EventEmitter","stage","createStage","canvas","getCanvas","info","getInfo","createViewport","pixelRatio","getContext","createViewportAwareInputHandler","createOrthoCamera","addCamera","update","innerHTML","finishLoading","createNewWorld","b2World","gameWorld","World","register","Vector2","addSystem","addListener","dispose","setTimeout","clearColor","loop","createGameLoop","clear","COLOR_BUFFER_BIT","setDelta","processActiveSystem","processPassiveSystem","setInterval","getFps","init"],"mappings":"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","file":"static/js/main.e3ad8d51.chunk.js","sourcesContent":["export default class Constants {\n  public static readonly CAMERA_WIDTH = 4;\n  public static readonly CAMERA_HEIGHT = 8;\n  public static readonly GAP = 1;\n  public static readonly GRAVITY = 20;\n  public static readonly PLAYER_WIDTH = 0.25;\n  public static readonly PLAYER_HEIGHT = 0.25;\n  public static readonly PLAYER_SCALE = 5;\n  public static readonly JUMP_FORCE = -10;\n  public static readonly RUN_FORCE = 2;\n\n  public static readonly BLOCK_BLOCK_SIZE = Constants.CAMERA_WIDTH * 2;\n  public static readonly BLOCK_SIZE = Constants.BLOCK_BLOCK_SIZE / 5;\n  public static readonly BLOCK_OFFSET_Y = Constants.CAMERA_HEIGHT / 1.7;\n}\n","import { b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\n\nexport default class PhysicsSystem extends System {\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  process(): void {\n    this.physicsWorld.Step(this.world.delta, 8, 3);\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { Vector2, Viewport } from 'gdxjs';\nimport Constants from '../Constants';\n\nexport default class CameraMovementSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    this.viewport.getCamera().setPosition(this.playerPos.x - Constants.GAP, camPos.y);\n  }\n}\n","import { b2Body, b2BodyDef, b2BodyType, b2PolygonShape, b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\nimport { Viewport } from 'gdxjs';\nimport Constants from '../Constants';\n\nexport default class BlockGenerationSystem extends System {\n  generatedStep = 0;\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('blocks')\n  blocks: Array<{ x: number; y: number; w: number; h: number; body: b2Body; type: number }>;\n  private createBox(x: number, y: number, w: number, h: number, type: number) {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_staticBody;\n    bodyDef.position.Set(x, y);\n    const body = this.physicsWorld.CreateBody(bodyDef);\n    body.SetUserData({ type: 'block' });\n    const shape = new b2PolygonShape();\n    shape.SetAsBox(w / 2, h / 2);\n    body.CreateFixture(shape);\n\n    this.blocks.push({ x, y, w, h, type, body });\n  }\n  initialized() {\n    while (this.generatedStep < 3) {\n      this.generateBlocks(this.generatedStep * Constants.BLOCK_BLOCK_SIZE);\n      this.generatedStep++;\n    }\n  }\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    const currentStep = Math.floor(camPos.x / Constants.BLOCK_BLOCK_SIZE);\n    while (this.generatedStep <= currentStep + 1) {\n      this.generateBlocks(this.generatedStep * Constants.BLOCK_BLOCK_SIZE);\n      this.generatedStep++;\n    }\n  }\n  private generateBlocks(offsetX: number) {\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        if (Math.random() > 0.3) {\n          this.createBox(\n            offsetX + Constants.BLOCK_SIZE * x,\n            Constants.BLOCK_OFFSET_Y + Constants.BLOCK_SIZE * y,\n            Constants.BLOCK_SIZE,\n            Constants.BLOCK_SIZE,\n            Math.floor(Math.random() * 3)\n          );\n        }\n      }\n    }\n  }\n}\n","import { b2Body } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\nimport { createBatch, createWhiteTexture, SpriteBatch, Texture, TextureAtlas, TextureRegion, Viewport } from 'gdxjs';\nimport AssetManager from '../AssetManager';\n\nexport default class BlockRenderSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('blocks')\n  blocks: Array<{ x: number; y: number; w: number; h: number; body: b2Body; type: number }>;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n\n  batch: SpriteBatch;\n  whiteTex: Texture;\n  atlas: TextureAtlas;\n  regions: TextureRegion[];\n  initialized() {\n    this.batch = createBatch(this.gl);\n    this.whiteTex = createWhiteTexture(this.gl);\n    const atlas = this.assetManager.getAtlas('./ground.atlas');\n    if (atlas) {\n      this.atlas = atlas;\n      this.regions = atlas.findRegions('tile');\n    }\n  }\n  process(): void {\n    this.batch.setProjection(this.viewport.getCamera().combined);\n    this.batch.begin();\n    for (let box of this.blocks) {\n      const { x, y, w, h, type } = box;\n      this.regions[type].draw(this.batch, x - w / 2, y - h / 2, w, h);\n    }\n    this.batch.end();\n  }\n}\n","import {\n  b2Body,\n  b2BodyDef,\n  b2BodyType,\n  b2CircleShape,\n  b2Contact,\n  b2ContactListener,\n  b2FixtureDef,\n  b2PolygonShape,\n  b2World\n} from 'box2d.ts';\nimport { EventEmitter } from 'fbemitter';\nimport { Inject, System } from 'flat-ecs';\nimport { Vector2 } from 'gdxjs';\nimport { ViewportAwareInputHandler } from 'gdxjs/lib/createViewportAwareInputHandler';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\n\nexport default class PlayerMovementSystem extends System {\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  @Inject('inputHandler')\n  inputHandler: ViewportAwareInputHandler;\n  @Inject('playerState')\n  playerState: PlayerState;\n  @Inject('eventEmitter')\n  eventEmitter: EventEmitter;\n  playerBody: b2Body;\n  initialized() {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_dynamicBody;\n    bodyDef.fixedRotation = true;\n    bodyDef.position.Set(2, 2);\n    const body = this.physicsWorld.CreateBody(bodyDef);\n    const shape = new b2CircleShape(Constants.PLAYER_WIDTH);\n    shape.Set({ x: -Constants.PLAYER_WIDTH / 2, y: -Constants.PLAYER_HEIGHT / 2 }, Constants.PLAYER_WIDTH);\n    body.CreateFixture(shape);\n\n    const sensorShape = new b2PolygonShape();\n    sensorShape.SetAsBox(Constants.PLAYER_WIDTH / 8, Constants.PLAYER_WIDTH / 8, {\n      x: 0,\n      y: Constants.PLAYER_HEIGHT / 2\n    });\n    const fixDef = new b2FixtureDef();\n    fixDef.isSensor = true;\n    fixDef.shape = sensorShape;\n    fixDef.userData = { type: 'playerSensor' };\n\n    body.CreateFixture(fixDef);\n\n    const sensorShape2 = new b2PolygonShape();\n    sensorShape2.SetAsBox(Constants.PLAYER_WIDTH / 8, Constants.PLAYER_WIDTH / 8, {\n      x: Constants.PLAYER_WIDTH / 2,\n      y: 0\n    });\n    const fixDef2 = new b2FixtureDef();\n    fixDef2.isSensor = true;\n    fixDef2.shape = sensorShape2;\n    fixDef2.userData = { type: 'playerSensor2' };\n\n    body.CreateFixture(fixDef2);\n\n    this.playerBody = body;\n\n    class ContactListener extends b2ContactListener {\n      movementSytem: PlayerMovementSystem;\n      constructor(movementSystem: PlayerMovementSystem) {\n        super();\n        this.movementSytem = movementSystem;\n      }\n      processJumpable(contact: b2Contact): void {\n        let otherFixture;\n\n        const fixA = contact.GetFixtureA();\n        const fixB = contact.GetFixtureB();\n\n        if (fixA.IsSensor() && fixA.GetUserData()?.type === 'playerSensor') {\n          otherFixture = fixB;\n        } else if (fixB.IsSensor() && fixB.GetUserData()?.type === 'playerSensor') {\n          otherFixture = fixA;\n        }\n\n        if (otherFixture && otherFixture.GetBody().GetUserData()?.type === 'block') {\n          this.movementSytem.jumpLeft = 2;\n          this.movementSytem.playerState.changeAction('run');\n        }\n      }\n      processObstacle(contact: b2Contact): void {\n        let otherFixture;\n\n        const fixA = contact.GetFixtureA();\n        const fixB = contact.GetFixtureB();\n\n        if (fixA.IsSensor() && fixA.GetUserData()?.type === 'playerSensor2') {\n          otherFixture = fixB;\n        } else if (fixB.IsSensor() && fixB.GetUserData()?.type === 'playerSensor2') {\n          otherFixture = fixA;\n        }\n\n        if (otherFixture && otherFixture.GetBody().GetUserData()?.type === 'block') {\n          this.movementSytem.stunnedDuration = 0.2;\n          this.movementSytem.playerBody.GetLinearVelocity().Set(0, 0);\n          this.movementSytem.playerBody.ApplyLinearImpulse({ x: -2.5 * Constants.RUN_FORCE, y: 0 }, { x: 0, y: 0 });\n\n          this.movementSytem.playerState.changeAction('hurt');\n        }\n      }\n      BeginContact(contact: b2Contact): void {\n        this.processJumpable(contact);\n        this.processObstacle(contact);\n      }\n    }\n    this.physicsWorld.SetContactListener(new ContactListener(this));\n  }\n  stunnedDuration = 0;\n  pressed = false;\n  jumpLeft = 0;\n  gameOver = false;\n  zeroCenter = { x: 0, y: 0 };\n  runImpulse = { x: Constants.RUN_FORCE, y: 0 };\n  jumpImpulse = { x: 0, y: Constants.JUMP_FORCE };\n  process(): void {\n    if (this.stunnedDuration > 0) {\n      this.stunnedDuration -= this.world.delta;\n      if (this.stunnedDuration <= 0) {\n        this.playerState.changeAction('run');\n      }\n    } else {\n      const v = this.playerBody.GetLinearVelocity();\n      v.Set(0, v.y);\n      this.playerBody.ApplyLinearImpulse(this.runImpulse, this.zeroCenter);\n\n      if (this.pressed) {\n        if (!this.inputHandler.isTouched()) {\n          this.pressed = false;\n        }\n      } else {\n        if (this.inputHandler.isTouched() && this.jumpLeft > 0) {\n          this.jumpLeft--;\n          if (this.jumpLeft === 1) {\n            this.playerState.changeAction('jump');\n          } else {\n            this.playerState.changeAction('doubleJump');\n          }\n          this.pressed = true;\n          const v = this.playerBody.GetLinearVelocity();\n          v.Set(v.x, 0);\n          this.playerBody.ApplyLinearImpulse(this.jumpImpulse, this.zeroCenter);\n        }\n      }\n    }\n    const bodyPos = this.playerBody.GetPosition();\n    this.playerPos.set(bodyPos.x, bodyPos.y);\n\n    if (!this.gameOver && bodyPos.y > Constants.CAMERA_HEIGHT * 1.2) {\n      this.gameOver = true;\n      this.eventEmitter.emit('gameOver');\n    }\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport {\n  createAnimation,\n  createBatch,\n  createWhiteTexture,\n  SpriteBatch,\n  Texture,\n  TextureAtlas,\n  Vector2,\n  Viewport,\n  Animation,\n  PlayMode,\n  TextureRegion\n} from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\n\nexport default class PlayerRenderSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('playerState')\n  playerState: PlayerState;\n  batch: SpriteBatch;\n  whiteTex: Texture;\n  atlas: TextureAtlas;\n  animations: any = {};\n  initialized() {\n    this.batch = createBatch(this.gl);\n    this.whiteTex = createWhiteTexture(this.gl);\n\n    const atlas = this.assetManager.getAtlas('./main-char.atlas');\n    if (atlas) {\n      this.atlas = atlas;\n    }\n  }\n  animationFrameDuration: any = {\n    run: 0.13,\n    jump: 0.1,\n    doubleJump: 0.1,\n    hurt: 0.05\n  };\n  getAnimation(action: string, state: string): Animation {\n    const animName = `${action}${state}`;\n    if (!this.animations[animName]) {\n      const frameDuration: number = this.animationFrameDuration[action] || 0.1;\n      let frames = this.atlas.findRegions(animName);\n      if (action === 'jump' || action === 'doubleJump') {\n        frames = frames.slice(0, frames.length - 2) as [TextureRegion];\n      }\n      this.animations[animName] = createAnimation(frameDuration, frames);\n    }\n    return this.animations[animName];\n  }\n  process(): void {\n    this.batch.setProjection(this.viewport.getCamera().combined);\n    this.batch.begin();\n    const { x, y } = this.playerPos;\n    this.playerState.process(this.world.delta);\n\n    let playMode = PlayMode.LOOP;\n    if (this.playerState.action === 'jump' || this.playerState.action === 'doubleJump') {\n      playMode = PlayMode.NORMAL;\n    }\n\n    const animation = this.getAnimation(this.playerState.action, this.playerState.state);\n    animation\n      .getKeyFrame(this.playerState.stateTime, playMode)\n      .draw(\n        this.batch,\n        x - Constants.PLAYER_WIDTH / 2,\n        y - Constants.PLAYER_HEIGHT / 2,\n        Constants.PLAYER_WIDTH,\n        Constants.PLAYER_HEIGHT,\n        Constants.PLAYER_WIDTH / 2,\n        Constants.PLAYER_HEIGHT,\n        0,\n        Constants.PLAYER_SCALE,\n        Constants.PLAYER_SCALE\n      );\n    this.batch.end();\n  }\n}\n","import { b2Body, b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\nimport { Viewport } from 'gdxjs';\nimport Constants from '../Constants';\n\nexport default class BlockRemovalSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('blocks')\n  blocks: Array<{ x: number; y: number; w: number; h: number; body: b2Body }>;\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    for (let i = this.blocks.length - 1; i >= 0; i--) {\n      const block = this.blocks[i];\n      if (camPos.x - block.x >= 3 * Constants.CAMERA_WIDTH) {\n        this.physicsWorld.DestroyBody(block.body);\n        this.blocks.splice(i, 1);\n      }\n    }\n  }\n}\n","import { loadAtlas, loadTexture, Texture, TextureAtlas } from 'gdxjs';\n\nexport default class AssetManager {\n  gl: WebGLRenderingContext;\n  promises: Array<Promise<any>> = [];\n  atlases: Map<string, TextureAtlas> = new Map();\n  textures: Map<string, Texture> = new Map();\n  done = 0;\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n  }\n  loadAtlas(path: string): void {\n    const promise = loadAtlas(this.gl, path, {}).then(atlas => {\n      this.atlases.set(path, atlas);\n      this.done++;\n    });\n    this.promises.push(promise);\n  }\n  getAtlas(path: string): TextureAtlas | undefined {\n    return this.atlases.get(path);\n  }\n  loadTexture(path: string): void {\n    const promise = loadTexture(this.gl, path, {}).then(atlas => {\n      this.textures.set(path, atlas);\n      this.done++;\n    });\n    this.promises.push(promise);\n  }\n  getTexture(path: string): Texture | undefined {\n    return this.textures.get(path);\n  }\n  async finishLoading() {\n    await Promise.all(this.promises);\n  }\n  getDone(): number {\n    return this.done;\n  }\n  getTotal(): number {\n    return this.promises.length;\n  }\n}\n","export default class PlayerState {\n  action: string = 'run';\n  state: string = 'A';\n  stateTime = 0;\n  changeAction(action: string) {\n    this.action = action;\n    this.stateTime = 0;\n  }\n  changeState(state: string) {\n    this.state = state;\n  }\n  process(delta: number) {\n    this.stateTime += delta;\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { createBatch, OrthographicCamera, SpriteBatch, Texture, Vector2 } from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\n\nexport default class BackgroundRenderSystem extends System {\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('fixedCamera')\n  fixedCamera: OrthographicCamera;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n\n  batch: SpriteBatch;\n  textures: Map<string, Texture | undefined> = new Map();\n  initialized() {\n    this.batch = createBatch(this.gl);\n    ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n      this.textures.set(s, this.assetManager.getTexture(`./background/${s}.png`))\n    );\n  }\n  drawBackground() {\n    const bg = this.textures.get('bg') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT;\n    const drawWidth = (drawHeight / bg.height) * bg.width;\n    let i = 0;\n    while (i * drawWidth < Constants.CAMERA_WIDTH) {\n      this.batch.draw(bg, i * drawWidth, 0, drawWidth, drawHeight);\n      i++;\n    }\n  }\n  process(): void {\n    const offset = -this.playerPos.x;\n    this.batch.setProjection(this.fixedCamera.combined);\n    this.batch.begin();\n    this.drawBackground();\n    this.drawCloud1(offset * 0.5);\n    this.drawCloud2(offset * 0.8);\n    this.drawCity1(offset);\n    this.drawCity2(offset * 1.1);\n    this.batch.end();\n  }\n  drawCity1(offset: number) {\n    const city = this.textures.get('city_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.5;\n    const drawWidth = (drawHeight / city.height) * city.width;\n    while (offset <= 0) {\n      offset += drawWidth;\n    }\n    this.batch.draw(city, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(city, offset, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth;\n    }\n  }\n  drawCity2(offset: number) {\n    const city = this.textures.get('city_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.5;\n    const drawWidth = (drawHeight / city.height) * city.width;\n    while (offset <= 0) {\n      offset += drawWidth;\n    }\n    this.batch.draw(city, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(city, offset, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth;\n    }\n  }\n  drawCloud1(offset: number) {\n    const cloud = this.textures.get('cloud_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.2;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = drawWidth;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n  drawCloud2(offset: number) {\n    const cloud = this.textures.get('cloud_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 6;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = drawWidth;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT / 4, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT / 4, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { createBatch, OrthographicCamera, SpriteBatch, Texture, Vector2 } from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\n\nexport default class SmokeRenderSystem extends System {\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('fixedCamera')\n  fixedCamera: OrthographicCamera;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n\n  batch: SpriteBatch;\n  textures: Map<string, Texture | undefined> = new Map();\n  initialized() {\n    this.batch = createBatch(this.gl);\n    ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n      this.textures.set(s, this.assetManager.getTexture(`./background/${s}.png`))\n    );\n  }\n  process(): void {\n    const offset = -this.playerPos.x;\n    this.batch.setProjection(this.fixedCamera.combined);\n    this.batch.begin();\n    this.drawCloud1(offset * 0.05);\n    this.drawCloud2(offset * 0.1);\n    this.batch.end();\n  }\n  drawCloud1(offset: number) {\n    const cloud = this.textures.get('smoke_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 5;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = -drawWidth / 1.5;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n  drawCloud2(offset: number) {\n    const cloud = this.textures.get('smoke_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 5;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = -drawWidth / 1.5;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n}\n","import {\n  createGameLoop,\n  createOrthoCamera,\n  createStage,\n  createViewport,\n  createViewportAwareInputHandler,\n  Vector2\n} from 'gdxjs';\nimport { b2Body, b2World } from 'box2d.ts';\nimport { World } from 'flat-ecs';\nimport './index.css';\nimport Constants from './Constants';\nimport PhysicsSystem from './systems/PhysicsSystem';\nimport CameraMovementSystem from './systems/CameraMovementSystem';\nimport BlockGenerationSystem from './systems/BlockGenerationSystem';\nimport BlockRenderSystem from './systems/BlockRenderSystem';\nimport PlayerMovementSystem from './systems/PlayerMovementSystem';\nimport PlayerRenderSystem from './systems/PlayerRenderSystem';\nimport BlockRemovalSystem from './systems/BlockRemovalSystem';\nimport AssetManager from './AssetManager';\nimport PlayerState from './PlayerState';\nimport BackgroundRenderSystem from './systems/BackgroundRenderSystem';\nimport SmokeRenderSystem from './systems/SmokeRenderSystem';\n\nimport { EventEmitter } from 'fbemitter';\n\nconst init = async () => {\n  const eventEmitter = new EventEmitter();\n  const stage = createStage();\n  const canvas = stage.getCanvas();\n  const info = stage.getInfo();\n\n  const viewport = createViewport(canvas, Constants.CAMERA_WIDTH, Constants.CAMERA_HEIGHT, {\n    pixelRatio: 1\n  });\n  const gl = viewport.getContext();\n  const inputHandler = createViewportAwareInputHandler(canvas, viewport);\n\n  const fixedCamera = createOrthoCamera(Constants.CAMERA_WIDTH, Constants.CAMERA_HEIGHT, canvas.width, canvas.height);\n  viewport.addCamera(fixedCamera);\n  viewport.update();\n\n  const assetManager = new AssetManager(gl);\n  assetManager.loadAtlas('./main-char.atlas');\n  assetManager.loadAtlas('./ground.atlas');\n  ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n    assetManager.loadTexture(`./background/${s}.png`)\n  );\n  info.innerHTML = `Loading...`;\n  await assetManager.finishLoading();\n\n  const createNewWorld = () => {\n    const blocks: Array<{ x: number; y: number; w: number; h: number; body: b2Body; type: number }> = [];\n    const physicsWorld = new b2World({ x: 0, y: Constants.GRAVITY });\n    const gameWorld = new World();\n    gameWorld.register('context', gl);\n    gameWorld.register('physicsWorld', physicsWorld);\n    gameWorld.register('viewport', viewport);\n    gameWorld.register('blocks', blocks);\n    gameWorld.register('playerPosition', new Vector2(0, 0));\n    gameWorld.register('inputHandler', inputHandler);\n    gameWorld.register('assetManager', assetManager);\n    gameWorld.register('playerState', new PlayerState());\n    gameWorld.register('fixedCamera', fixedCamera);\n    gameWorld.register('eventEmitter', eventEmitter);\n\n    gameWorld.addSystem(new BlockGenerationSystem(), true);\n    gameWorld.addSystem(new PlayerMovementSystem(), true);\n    gameWorld.addSystem(new BlockRemovalSystem(), true);\n    gameWorld.addSystem(new PhysicsSystem(), true);\n\n    gameWorld.addSystem(new CameraMovementSystem(), false);\n    gameWorld.addSystem(new BackgroundRenderSystem(), false);\n    gameWorld.addSystem(new BlockRenderSystem(), false);\n    gameWorld.addSystem(new PlayerRenderSystem(), false);\n    gameWorld.addSystem(new SmokeRenderSystem(), false);\n    return gameWorld;\n  };\n\n  let gameWorld = createNewWorld();\n  let gameOver = false;\n\n  eventEmitter.addListener('gameOver', () => {\n    gameOver = true;\n    gameWorld.dispose();\n    setTimeout(() => {\n      gameWorld = createNewWorld();\n      gameOver = false;\n    }, 1000);\n  });\n\n  gl.clearColor(0, 0, 0, 1);\n  const loop = createGameLoop(delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gameWorld.setDelta(delta);\n    !gameOver && gameWorld.processActiveSystem();\n    gameWorld.processPassiveSystem();\n  });\n\n  setInterval(() => (info.innerHTML = `FPS: ${loop.getFps()}`), 500);\n};\n\ninit();\n"],"sourceRoot":""}