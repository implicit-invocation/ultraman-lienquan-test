{"version":3,"sources":["Constants.ts","systems/PhysicsSystem.ts","systems/CameraMovementSystem.ts","systems/BlockGenerationSystem.ts","systems/BlockRenderSystem.ts","systems/PlayerMovementSystem.ts","systems/PlayerRenderSystem.ts","systems/BlockRemovalSystem.ts","AssetManager.ts","PlayerState.ts","systems/BackgroundRenderSystem.ts","systems/SmokeRenderSystem.ts","index.tsx"],"names":["Constants","CAMERA_WIDTH","CAMERA_HEIGHT","GAP","GRAVITY","PLAYER_WIDTH","PLAYER_HEIGHT","PLAYER_SCALE","JUMP_FORCE","RUN_FORCE","TOTAL_BLOCK_HEIGHT","BLOCK_BLOCK_SIZE","BLOCK_SIZE","BLOCK_OFFSET_Y","PhysicsSystem","Inject","this","physicsWorld","Step","world","delta","System","CameraMovementSystem","camPos","viewport","getCamera","getPosition","setPosition","playerPos","x","y","BlockGenerationSystem","generatedStep","w","h","type","bodyDef","b2BodyDef","b2BodyType","b2_staticBody","position","Set","body","CreateBody","SetUserData","shape","b2PolygonShape","SetAsBox","CreateFixture","blocks","push","generateBlocks","currentStep","Math","floor","offsetX","first","patternType","random","patterns","length","pattern","cell","createBox","map","s","grid","split","xs","ys","xss","parseInt","yss","newXss","newYss","BlockRenderSystem","batch","whiteTex","atlas","regions","createBatch","gl","createWhiteTexture","assetManager","getAtlas","findRegions","setProjection","combined","begin","box","draw","end","PlayerMovementSystem","playerBody","stunnedDuration","pressed","jumpLeft","gameOver","zeroCenter","runImpulse","jumpImpulse","b2_dynamicBody","fixedRotation","b2CircleShape","sensorShape","fixDef","b2FixtureDef","isSensor","userData","sensorShape2","fixDef2","ContactListener","movementSystem","movementSytem","contact","otherFixture","fixA","GetFixtureA","fixB","GetFixtureB","IsSensor","GetUserData","GetBody","playerState","changeAction","GetLinearVelocity","ApplyLinearImpulse","processJumpable","processObstacle","b2ContactListener","SetContactListener","v","inputHandler","isTouched","bodyPos","GetPosition","set","eventEmitter","emit","PlayerRenderSystem","animations","animationFrameDuration","run","jump","doubleJump","hurt","action","state","animName","frameDuration","frames","slice","createAnimation","process","playMode","PlayMode","LOOP","NORMAL","getAnimation","getKeyFrame","stateTime","BlockRemovalSystem","i","block","DestroyBody","splice","AssetManager","promises","atlases","Map","textures","done","path","promise","loadAtlas","then","get","loadTexture","Promise","all","PlayerState","BackgroundRenderSystem","getTexture","bg","drawHeight","drawWidth","height","width","offset","fixedCamera","drawBackground","drawCloud1","drawCloud2","drawCity1","drawCity2","city","cloud","gap","SmokeRenderSystem","a","EventEmitter","stage","createStage","canvas","getCanvas","info","getInfo","createViewport","pixelRatio","getContext","createViewportAwareInputHandler","createOrthoCamera","addCamera","update","innerHTML","finishLoading","createNewWorld","b2World","gameWorld","World","register","Vector2","addSystem","addListener","dispose","setTimeout","clearColor","loop","createGameLoop","clear","COLOR_BUFFER_BIT","setDelta","processActiveSystem","processPassiveSystem","setInterval","getFps","init"],"mappings":"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","file":"static/js/main.f38ca069.chunk.js","sourcesContent":["export default class Constants {\n  public static readonly CAMERA_WIDTH = 4;\n  public static readonly CAMERA_HEIGHT = 8;\n  public static readonly GAP = 1;\n  public static readonly GRAVITY = 20;\n  public static readonly PLAYER_WIDTH = 0.2;\n  public static readonly PLAYER_HEIGHT = 0.2;\n  public static readonly PLAYER_SCALE = 5;\n  public static readonly JUMP_FORCE = -10;\n  public static readonly RUN_FORCE = 2;\n\n  public static readonly TOTAL_BLOCK_HEIGHT = 15;\n  public static readonly BLOCK_BLOCK_SIZE = Constants.CAMERA_WIDTH * 2.1;\n  public static readonly BLOCK_SIZE = Constants.CAMERA_HEIGHT / Constants.TOTAL_BLOCK_HEIGHT;\n  public static readonly BLOCK_OFFSET_Y = Constants.CAMERA_HEIGHT / 1.7;\n}\n","import { b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\n\nexport default class PhysicsSystem extends System {\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  process(): void {\n    this.physicsWorld.Step(this.world.delta, 8, 3);\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { Vector2, Viewport } from 'gdxjs';\nimport Constants from '../Constants';\n\nexport default class CameraMovementSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    this.viewport.getCamera().setPosition(this.playerPos.x - Constants.GAP, camPos.y);\n  }\n}\n","import { b2Body, b2BodyDef, b2BodyType, b2PolygonShape, b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\nimport { Viewport } from 'gdxjs';\nimport Constants from '../Constants';\n\nconst processPattern = (s: string): number[][] => {\n  const grid: number[][] = [];\n  const blocks = s.split(';');\n  for (let block of blocks) {\n    const [xs, ys] = block.split(',');\n    let xss = xs.split('-').map(s => parseInt(s));\n    let yss = ys.split('-').map(s => parseInt(s));\n    if (xss.length === 2) {\n      const newXss = [];\n      for (let x = xss[0]; x <= xss[1]; x++) {\n        newXss.push(x);\n      }\n      xss = newXss;\n    }\n    if (yss.length === 2) {\n      const newYss = [];\n      for (let x = yss[0]; x <= yss[1]; x++) {\n        newYss.push(x);\n      }\n      yss = newYss;\n    }\n    for (let x of xss) {\n      for (let y of yss) {\n        grid.push([x, y]);\n      }\n    }\n  }\n  return grid;\n};\n\nexport default class BlockGenerationSystem extends System {\n  generatedStep = 0;\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('blocks')\n  blocks: Array<{ x: number; y: number; w: number; h: number; body: b2Body; type: number }>;\n  private createBox(x: number, y: number, w: number, h: number, type: number) {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_staticBody;\n    bodyDef.position.Set(x, y);\n    const body = this.physicsWorld.CreateBody(bodyDef);\n    body.SetUserData({ type: 'block' });\n    const shape = new b2PolygonShape();\n    shape.SetAsBox(w / 2, h / 2);\n    body.CreateFixture(shape);\n\n    this.blocks.push({ x, y, w, h, type, body });\n  }\n  initialized() {\n    while (this.generatedStep < 2) {\n      this.generateBlocks(this.generatedStep * Constants.BLOCK_BLOCK_SIZE, true);\n      this.generatedStep++;\n    }\n  }\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    const currentStep = Math.floor(camPos.x / Constants.BLOCK_BLOCK_SIZE);\n    while (this.generatedStep <= currentStep + 1) {\n      this.generateBlocks(this.generatedStep * Constants.BLOCK_BLOCK_SIZE);\n      this.generatedStep++;\n    }\n  }\n\n  static patterns = [\n    '1-10,2',\n    '1-4,2;6-9,2;4,3-5;5,4;5,8-10;6,7-10;7,7-8',\n    '1-9,2;3,3-5;6-8,3;6-7,4',\n    '1-9,2;4,5-8;2,11;6,11;2-6,12;2-6,13',\n    '1-5,2;8-12,2;3-5,3;8-10,3;4-5,4;8-9,4;5-8,5;2-8,11;3-7,12;4-6,13',\n    '1-5,2;8-12,2;4-5,3;8-9,3;4-5,4;8-9,4',\n    '1-14,2;4-10,5;4-10,6;4,7;10,7;7,9-12',\n    '1-14,2;4-5,3;9-11,3;4,4;10,4;5-6,10;4-11,11;4-11,12'\n  ].map(processPattern);\n\n  private generateBlocks(offsetX: number, first = false) {\n    const patternType = first ? 0 : Math.floor(Math.random() * (BlockGenerationSystem.patterns.length - 1)) + 1;\n    const pattern = BlockGenerationSystem.patterns[patternType];\n    for (let cell of pattern) {\n      const [x, y] = cell;\n      this.createBox(\n        offsetX + Constants.BLOCK_SIZE * x,\n        (Constants.TOTAL_BLOCK_HEIGHT - y) * Constants.BLOCK_SIZE,\n        Constants.BLOCK_SIZE,\n        Constants.BLOCK_SIZE,\n        Math.floor(Math.random() * 3)\n      );\n    }\n  }\n}\n","import { b2Body } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\nimport { createBatch, createWhiteTexture, SpriteBatch, Texture, TextureAtlas, TextureRegion, Viewport } from 'gdxjs';\nimport AssetManager from '../AssetManager';\n\nexport default class BlockRenderSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('blocks')\n  blocks: Array<{ x: number; y: number; w: number; h: number; body: b2Body; type: number }>;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n\n  batch: SpriteBatch;\n  whiteTex: Texture;\n  atlas: TextureAtlas;\n  regions: TextureRegion[];\n  initialized() {\n    this.batch = createBatch(this.gl);\n    this.whiteTex = createWhiteTexture(this.gl);\n    const atlas = this.assetManager.getAtlas('./ground.atlas');\n    if (atlas) {\n      this.atlas = atlas;\n      this.regions = atlas.findRegions('tile');\n    }\n  }\n  process(): void {\n    this.batch.setProjection(this.viewport.getCamera().combined);\n    this.batch.begin();\n    for (let box of this.blocks) {\n      const { x, y, w, h, type } = box;\n      this.regions[type].draw(this.batch, x - w / 2, y - h / 2, w, h);\n    }\n    this.batch.end();\n  }\n}\n","import {\n  b2Body,\n  b2BodyDef,\n  b2BodyType,\n  b2CircleShape,\n  b2Contact,\n  b2ContactListener,\n  b2FixtureDef,\n  b2PolygonShape,\n  b2World\n} from 'box2d.ts';\nimport { EventEmitter } from 'fbemitter';\nimport { Inject, System } from 'flat-ecs';\nimport { Vector2 } from 'gdxjs';\nimport { ViewportAwareInputHandler } from 'gdxjs/lib/createViewportAwareInputHandler';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\n\nexport default class PlayerMovementSystem extends System {\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  @Inject('inputHandler')\n  inputHandler: ViewportAwareInputHandler;\n  @Inject('playerState')\n  playerState: PlayerState;\n  @Inject('eventEmitter')\n  eventEmitter: EventEmitter;\n  playerBody: b2Body;\n  initialized() {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_dynamicBody;\n    bodyDef.fixedRotation = true;\n    bodyDef.position.Set(2, Constants.CAMERA_HEIGHT / 2);\n    const body = this.physicsWorld.CreateBody(bodyDef);\n    const shape = new b2CircleShape(Constants.PLAYER_WIDTH);\n    shape.Set({ x: -Constants.PLAYER_WIDTH / 2, y: -Constants.PLAYER_HEIGHT / 2 }, Constants.PLAYER_WIDTH);\n    body.CreateFixture(shape);\n\n    const sensorShape = new b2PolygonShape();\n    sensorShape.SetAsBox(Constants.PLAYER_WIDTH / 8, Constants.PLAYER_WIDTH / 8, {\n      x: 0,\n      y: Constants.PLAYER_HEIGHT / 2\n    });\n    const fixDef = new b2FixtureDef();\n    fixDef.isSensor = true;\n    fixDef.shape = sensorShape;\n    fixDef.userData = { type: 'playerSensor' };\n\n    body.CreateFixture(fixDef);\n\n    const sensorShape2 = new b2PolygonShape();\n    sensorShape2.SetAsBox(Constants.PLAYER_WIDTH / 8, Constants.PLAYER_WIDTH / 8, {\n      x: Constants.PLAYER_WIDTH / 2,\n      y: 0\n    });\n    const fixDef2 = new b2FixtureDef();\n    fixDef2.isSensor = true;\n    fixDef2.shape = sensorShape2;\n    fixDef2.userData = { type: 'playerSensor2' };\n\n    body.CreateFixture(fixDef2);\n\n    this.playerBody = body;\n\n    class ContactListener extends b2ContactListener {\n      movementSytem: PlayerMovementSystem;\n      constructor(movementSystem: PlayerMovementSystem) {\n        super();\n        this.movementSytem = movementSystem;\n      }\n      processJumpable(contact: b2Contact): void {\n        let otherFixture;\n\n        const fixA = contact.GetFixtureA();\n        const fixB = contact.GetFixtureB();\n\n        if (fixA.IsSensor() && fixA.GetUserData()?.type === 'playerSensor') {\n          otherFixture = fixB;\n        } else if (fixB.IsSensor() && fixB.GetUserData()?.type === 'playerSensor') {\n          otherFixture = fixA;\n        }\n\n        if (otherFixture && otherFixture.GetBody().GetUserData()?.type === 'block') {\n          this.movementSytem.jumpLeft = 2;\n          this.movementSytem.playerState.changeAction('run');\n        }\n      }\n      processObstacle(contact: b2Contact): void {\n        let otherFixture;\n\n        const fixA = contact.GetFixtureA();\n        const fixB = contact.GetFixtureB();\n\n        if (fixA.IsSensor() && fixA.GetUserData()?.type === 'playerSensor2') {\n          otherFixture = fixB;\n        } else if (fixB.IsSensor() && fixB.GetUserData()?.type === 'playerSensor2') {\n          otherFixture = fixA;\n        }\n\n        if (otherFixture && otherFixture.GetBody().GetUserData()?.type === 'block') {\n          this.movementSytem.stunnedDuration = 0.2;\n          this.movementSytem.playerBody.GetLinearVelocity().Set(0, 0);\n          this.movementSytem.playerBody.ApplyLinearImpulse({ x: -2 * Constants.RUN_FORCE, y: 0 }, { x: 0, y: 0 });\n\n          this.movementSytem.playerState.changeAction('hurt');\n        }\n      }\n      BeginContact(contact: b2Contact): void {\n        this.processJumpable(contact);\n        this.processObstacle(contact);\n      }\n    }\n    this.physicsWorld.SetContactListener(new ContactListener(this));\n  }\n  stunnedDuration = 0;\n  pressed = false;\n  jumpLeft = 0;\n  gameOver = false;\n  zeroCenter = { x: 0, y: 0 };\n  runImpulse = { x: Constants.RUN_FORCE, y: 0 };\n  jumpImpulse = { x: 0, y: Constants.JUMP_FORCE };\n  process(): void {\n    if (this.stunnedDuration > 0) {\n      this.stunnedDuration -= this.world.delta;\n      if (this.stunnedDuration <= 0) {\n        this.playerState.changeAction('run');\n      }\n    } else {\n      const v = this.playerBody.GetLinearVelocity();\n      v.Set(0, v.y);\n      this.playerBody.ApplyLinearImpulse(this.runImpulse, this.zeroCenter);\n\n      if (this.pressed) {\n        if (!this.inputHandler.isTouched()) {\n          this.pressed = false;\n        }\n      } else {\n        if (this.inputHandler.isTouched() && this.jumpLeft > 0) {\n          this.jumpLeft--;\n          if (this.jumpLeft === 1) {\n            this.playerState.changeAction('jump');\n          } else {\n            this.playerState.changeAction('doubleJump');\n          }\n          this.pressed = true;\n          const v = this.playerBody.GetLinearVelocity();\n          v.Set(v.x, 0);\n          this.playerBody.ApplyLinearImpulse(this.jumpImpulse, this.zeroCenter);\n        }\n      }\n    }\n    const bodyPos = this.playerBody.GetPosition();\n    this.playerPos.set(bodyPos.x, bodyPos.y);\n\n    if (!this.gameOver && bodyPos.y > Constants.CAMERA_HEIGHT * 1.2) {\n      this.gameOver = true;\n      this.eventEmitter.emit('gameOver');\n    }\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport {\n  createAnimation,\n  createBatch,\n  createWhiteTexture,\n  SpriteBatch,\n  Texture,\n  TextureAtlas,\n  Vector2,\n  Viewport,\n  Animation,\n  PlayMode,\n  TextureRegion\n} from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\n\nexport default class PlayerRenderSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('playerState')\n  playerState: PlayerState;\n  batch: SpriteBatch;\n  whiteTex: Texture;\n  atlas: TextureAtlas;\n  animations: any = {};\n  initialized() {\n    this.batch = createBatch(this.gl);\n    this.whiteTex = createWhiteTexture(this.gl);\n\n    const atlas = this.assetManager.getAtlas('./main-char.atlas');\n    if (atlas) {\n      this.atlas = atlas;\n    }\n  }\n  animationFrameDuration: any = {\n    run: 0.13,\n    jump: 0.1,\n    doubleJump: 0.1,\n    hurt: 0.05\n  };\n  getAnimation(action: string, state: string): Animation {\n    const animName = `${action}${state}`;\n    if (!this.animations[animName]) {\n      const frameDuration: number = this.animationFrameDuration[action] || 0.1;\n      let frames = this.atlas.findRegions(animName);\n      if (action === 'jump' || action === 'doubleJump') {\n        frames = frames.slice(0, frames.length - 2) as [TextureRegion];\n      }\n      this.animations[animName] = createAnimation(frameDuration, frames);\n    }\n    return this.animations[animName];\n  }\n  process(): void {\n    this.batch.setProjection(this.viewport.getCamera().combined);\n    this.batch.begin();\n    const { x, y } = this.playerPos;\n    this.playerState.process(this.world.delta);\n\n    let playMode = PlayMode.LOOP;\n    if (this.playerState.action === 'jump' || this.playerState.action === 'doubleJump') {\n      playMode = PlayMode.NORMAL;\n    }\n\n    const animation = this.getAnimation(this.playerState.action, this.playerState.state);\n    animation\n      .getKeyFrame(this.playerState.stateTime, playMode)\n      .draw(\n        this.batch,\n        x - Constants.PLAYER_WIDTH / 2,\n        y - Constants.PLAYER_HEIGHT / 2,\n        Constants.PLAYER_WIDTH,\n        Constants.PLAYER_HEIGHT,\n        Constants.PLAYER_WIDTH / 2,\n        Constants.PLAYER_HEIGHT,\n        0,\n        Constants.PLAYER_SCALE,\n        Constants.PLAYER_SCALE\n      );\n    this.batch.end();\n  }\n}\n","import { b2Body, b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\nimport { Viewport } from 'gdxjs';\nimport Constants from '../Constants';\n\nexport default class BlockRemovalSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('blocks')\n  blocks: Array<{ x: number; y: number; w: number; h: number; body: b2Body }>;\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    for (let i = this.blocks.length - 1; i >= 0; i--) {\n      const block = this.blocks[i];\n      if (camPos.x - block.x >= 3 * Constants.CAMERA_WIDTH) {\n        this.physicsWorld.DestroyBody(block.body);\n        this.blocks.splice(i, 1);\n      }\n    }\n  }\n}\n","import { loadAtlas, loadTexture, Texture, TextureAtlas } from 'gdxjs';\n\nexport default class AssetManager {\n  gl: WebGLRenderingContext;\n  promises: Array<Promise<any>> = [];\n  atlases: Map<string, TextureAtlas> = new Map();\n  textures: Map<string, Texture> = new Map();\n  done = 0;\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n  }\n  loadAtlas(path: string): void {\n    const promise = loadAtlas(this.gl, path, {}).then(atlas => {\n      this.atlases.set(path, atlas);\n      this.done++;\n    });\n    this.promises.push(promise);\n  }\n  getAtlas(path: string): TextureAtlas | undefined {\n    return this.atlases.get(path);\n  }\n  loadTexture(path: string): void {\n    const promise = loadTexture(this.gl, path, {}).then(atlas => {\n      this.textures.set(path, atlas);\n      this.done++;\n    });\n    this.promises.push(promise);\n  }\n  getTexture(path: string): Texture | undefined {\n    return this.textures.get(path);\n  }\n  async finishLoading() {\n    await Promise.all(this.promises);\n  }\n  getDone(): number {\n    return this.done;\n  }\n  getTotal(): number {\n    return this.promises.length;\n  }\n}\n","export default class PlayerState {\n  action: string = 'run';\n  state: string = 'A';\n  stateTime = 0;\n  changeAction(action: string) {\n    if (action === this.action) return;\n    this.action = action;\n    this.stateTime = 0;\n  }\n  changeState(state: string) {\n    this.state = state;\n  }\n  process(delta: number) {\n    this.stateTime += delta;\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { createBatch, OrthographicCamera, SpriteBatch, Texture, Vector2 } from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\n\nexport default class BackgroundRenderSystem extends System {\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('fixedCamera')\n  fixedCamera: OrthographicCamera;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n\n  batch: SpriteBatch;\n  textures: Map<string, Texture | undefined> = new Map();\n  initialized() {\n    this.batch = createBatch(this.gl);\n    ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n      this.textures.set(s, this.assetManager.getTexture(`./background/${s}.png`))\n    );\n  }\n  drawBackground() {\n    const bg = this.textures.get('bg') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT;\n    const drawWidth = (drawHeight / bg.height) * bg.width;\n    let i = 0;\n    while (i * drawWidth < Constants.CAMERA_WIDTH) {\n      this.batch.draw(bg, i * drawWidth, 0, drawWidth, drawHeight);\n      i++;\n    }\n  }\n  process(): void {\n    const offset = -this.playerPos.x;\n    this.batch.setProjection(this.fixedCamera.combined);\n    this.batch.begin();\n    this.drawBackground();\n    this.drawCloud1(offset * 0.5);\n    this.drawCloud2(offset * 0.8);\n    this.drawCity1(offset);\n    this.drawCity2(offset * 1.1);\n    this.batch.end();\n  }\n  drawCity1(offset: number) {\n    const city = this.textures.get('city_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.5;\n    const drawWidth = (drawHeight / city.height) * city.width;\n    while (offset <= 0) {\n      offset += drawWidth;\n    }\n    this.batch.draw(city, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(city, offset, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth;\n    }\n  }\n  drawCity2(offset: number) {\n    const city = this.textures.get('city_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.5;\n    const drawWidth = (drawHeight / city.height) * city.width;\n    while (offset <= 0) {\n      offset += drawWidth;\n    }\n    this.batch.draw(city, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(city, offset, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth;\n    }\n  }\n  drawCloud1(offset: number) {\n    const cloud = this.textures.get('cloud_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.2;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = drawWidth;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n  drawCloud2(offset: number) {\n    const cloud = this.textures.get('cloud_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 6;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = drawWidth;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT / 4, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT / 4, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { createBatch, OrthographicCamera, SpriteBatch, Texture, Vector2 } from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\n\nexport default class SmokeRenderSystem extends System {\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('fixedCamera')\n  fixedCamera: OrthographicCamera;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n\n  batch: SpriteBatch;\n  textures: Map<string, Texture | undefined> = new Map();\n  initialized() {\n    this.batch = createBatch(this.gl);\n    ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n      this.textures.set(s, this.assetManager.getTexture(`./background/${s}.png`))\n    );\n  }\n  process(): void {\n    const offset = -this.playerPos.x;\n    this.batch.setProjection(this.fixedCamera.combined);\n    this.batch.begin();\n    this.drawCloud1(offset * 0.05);\n    this.drawCloud2(offset * 0.1);\n    this.batch.end();\n  }\n  drawCloud1(offset: number) {\n    const cloud = this.textures.get('smoke_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 5;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = -drawWidth / 1.5;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n  drawCloud2(offset: number) {\n    const cloud = this.textures.get('smoke_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 5;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = -drawWidth / 1.5;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n}\n","import {\n  createGameLoop,\n  createOrthoCamera,\n  createStage,\n  createViewport,\n  createViewportAwareInputHandler,\n  Vector2\n} from 'gdxjs';\nimport { b2Body, b2World } from 'box2d.ts';\nimport { World } from 'flat-ecs';\nimport './index.css';\nimport Constants from './Constants';\nimport PhysicsSystem from './systems/PhysicsSystem';\nimport CameraMovementSystem from './systems/CameraMovementSystem';\nimport BlockGenerationSystem from './systems/BlockGenerationSystem';\nimport BlockRenderSystem from './systems/BlockRenderSystem';\nimport PlayerMovementSystem from './systems/PlayerMovementSystem';\nimport PlayerRenderSystem from './systems/PlayerRenderSystem';\nimport BlockRemovalSystem from './systems/BlockRemovalSystem';\nimport AssetManager from './AssetManager';\nimport PlayerState from './PlayerState';\nimport BackgroundRenderSystem from './systems/BackgroundRenderSystem';\nimport SmokeRenderSystem from './systems/SmokeRenderSystem';\n\nimport { EventEmitter } from 'fbemitter';\n\nconst init = async () => {\n  const eventEmitter = new EventEmitter();\n  const stage = createStage();\n  const canvas = stage.getCanvas();\n  const info = stage.getInfo();\n\n  const viewport = createViewport(canvas, Constants.CAMERA_WIDTH, Constants.CAMERA_HEIGHT, {\n    pixelRatio: 1\n  });\n  const gl = viewport.getContext();\n  const inputHandler = createViewportAwareInputHandler(canvas, viewport);\n\n  const fixedCamera = createOrthoCamera(Constants.CAMERA_WIDTH, Constants.CAMERA_HEIGHT, canvas.width, canvas.height);\n  viewport.addCamera(fixedCamera);\n  viewport.update();\n\n  const assetManager = new AssetManager(gl);\n  assetManager.loadAtlas('./main-char.atlas');\n  assetManager.loadAtlas('./ground.atlas');\n  ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n    assetManager.loadTexture(`./background/${s}.png`)\n  );\n  info.innerHTML = `Loading...`;\n  await assetManager.finishLoading();\n\n  const createNewWorld = () => {\n    const blocks: Array<{ x: number; y: number; w: number; h: number; body: b2Body; type: number }> = [];\n    const physicsWorld = new b2World({ x: 0, y: Constants.GRAVITY });\n    const gameWorld = new World();\n    gameWorld.register('context', gl);\n    gameWorld.register('physicsWorld', physicsWorld);\n    gameWorld.register('viewport', viewport);\n    gameWorld.register('blocks', blocks);\n    gameWorld.register('playerPosition', new Vector2(0, 0));\n    gameWorld.register('inputHandler', inputHandler);\n    gameWorld.register('assetManager', assetManager);\n    gameWorld.register('playerState', new PlayerState());\n    gameWorld.register('fixedCamera', fixedCamera);\n    gameWorld.register('eventEmitter', eventEmitter);\n\n    gameWorld.addSystem(new BlockGenerationSystem(), true);\n    gameWorld.addSystem(new PlayerMovementSystem(), true);\n    gameWorld.addSystem(new BlockRemovalSystem(), true);\n    gameWorld.addSystem(new PhysicsSystem(), true);\n\n    gameWorld.addSystem(new CameraMovementSystem(), false);\n    gameWorld.addSystem(new BackgroundRenderSystem(), false);\n    gameWorld.addSystem(new BlockRenderSystem(), false);\n    gameWorld.addSystem(new PlayerRenderSystem(), false);\n    gameWorld.addSystem(new SmokeRenderSystem(), false);\n    return gameWorld;\n  };\n\n  let gameWorld = createNewWorld();\n  let gameOver = false;\n\n  eventEmitter.addListener('gameOver', () => {\n    gameOver = true;\n    gameWorld.dispose();\n    setTimeout(() => {\n      gameWorld = createNewWorld();\n      gameOver = false;\n    }, 1000);\n  });\n\n  gl.clearColor(0, 0, 0, 1);\n  const loop = createGameLoop(delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gameWorld.setDelta(delta);\n    !gameOver && gameWorld.processActiveSystem();\n    gameWorld.processPassiveSystem();\n  });\n\n  setInterval(() => (info.innerHTML = `FPS: ${loop.getFps()}`), 500);\n};\n\ninit();\n"],"sourceRoot":""}