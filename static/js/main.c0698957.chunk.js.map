{"version":3,"sources":["AssetManager.ts","Constants.ts","PlayerState.ts","systems/AlienRenderSystem.ts","systems/AlienSystem.ts","systems/BackgroundRenderSystem.ts","systems/BlockGenerationSystem.ts","systems/BlockRemovalSystem.ts","systems/BlockRenderSystem.ts","systems/CameraMovementSystem.ts","systems/PhysicsSystem.ts","systems/UISystem.ts","systems/PlayerMovementSystem.ts","systems/PlayerRenderSystem.ts","systems/SmokeRenderSystem.ts","systems/StarCollisionSystem.ts","systems/StarRenderSystem.ts","screens/createLoadingScreen.ts","screens/createGameScreen.ts","index.tsx"],"names":["AssetManager","gl","promises","atlases","Map","textures","done","fonts","this","path","promise","loadAtlas","then","atlas","set","push","loadFont","font","get","loadTexture","Promise","all","length","Constants","CAMERA_WIDTH","CAMERA_HEIGHT","GAP","GRAVITY","PLAYER_WIDTH","PLAYER_HEIGHT","PLAYER_SCALE","JUMP_FORCE","RUN_FORCE","STAR_SIZE","TRANSITION_DURATION","ALIEN_SPAWNING_TIME","ALIEN_WIDTH","ALIEN_SPEED","ALIEN_YS","ALIEN_HEIGHT","TOTAL_BLOCK_HEIGHT","BLOCK_BLOCK_SIZE","BLOCK_SIZE","BLOCK_OFFSET_Y","PlayerState","action","state","stateTime","states","stateIndex","transitionTime","stunnedDuration","appliedStun","hp","score","complete","index","changeState","delta","AlienRenderSystem","Inject","batch","animations","elapsed","createBatch","assetManager","getAtlas","forEach","s","createAnimation","findRegions","setProjection","fixedCamera","combined","begin","world","aliens","alien","type","getKeyFrame","time","PlayMode","NORMAL","draw","x","y","end","System","AlienSystem","i","hit","py","playerPos","playerState","changeAction","splice","BackgroundRenderSystem","map","getTexture","bg","drawHeight","drawWidth","height","width","offset","drawBackground","drawCloud1","drawCloud2","drawCity1","drawCity2","city","cloud","gap","BlockGenerationSystem","generatedStep","w","h","bodyDef","b2BodyDef","b2BodyType","b2_staticBody","position","Set","body","physicsWorld","CreateBody","SetUserData","shape","b2PolygonShape","SetAsBox","CreateFixture","blocks","generateBlocks","camPos","viewport","getCamera","getPosition","currentStep","Math","floor","special","fixDef","b2FixtureDef","isSensor","starObject","active","m_userData","stars","offsetX","first","patternType","random","patterns","starPattern","starPatterns","pattern","cell","createBox","specialGenerated","star","createStar","grid","split","xs","ys","xss","parseInt","yss","newXss","newYss","undefined","parseFloat","BlockRemovalSystem","block","DestroyBody","BlockRenderSystem","whiteTex","regions","createWhiteTexture","box","CameraMovementSystem","setPosition","PhysicsSystem","Step","padNumber","number","result","UISystem","panel","heartFull","heartEmpty","bar","scoreLabel","text","whiteText","getFont","createRenderer","setAlignMode","AlignMode","right","panelWidth","panelHeight","panelDrawWidth","panelDrawHeight","panelDrawX","panelDrawY","heartDrawWidth","heartDrawHeight","heartStartX","heartStartY","heartGap","barDrawX","barDrawWidth","barDrawHeight","barDrawY","scoreLabelWidth","scoreDrawHeight","scoreDrawWidth","scoreDrawY","scoreDrawX","fontSize","textDrawY","setDisplayWidth","coverStartX","coverGap","coverWidth","coverStartY","setColor","coverHeight","PlayerMovementSystem","playerBody","pressed","jumpLeft","gameOver","zeroCenter","runImpulse","jumpImpulse","b2_dynamicBody","fixedRotation","b2CircleShape","sensorShape","userData","sensorShape2","fixDef2","ContactListener","movementSystem","movementSytem","contact","otherFixture","fixA","GetFixtureA","fixB","GetFixtureB","IsSensor","GetUserData","GetBody","processJumpable","processObstacle","eventEmitter","emit","b2ContactListener","SetContactListener","GetLinearVelocity","ApplyLinearImpulse","v","inputHandler","isTouched","bodyPos","GetPosition","PlayerRenderSystem","animationFrameDuration","run","jump","doubleJump","hurt","animName","frameDuration","frames","slice","process","playMode","LOOP","getAnimation","SmokeRenderSystem","StarCollisionSystem","subscription","addListener","starFixture","removeStar","nextState","remove","StarRenderSystem","starAnimation","specialAnimations","getCurrentStateIndex","createLoadingScreen","game","getContext","finishLoading","setTimeout","setScreen","createViewportAwareInputHandler","getCanvas","createNewWorld","b2World","gameWorld","World","playerPosition","Vector2","register","addSystem","dispose","whiteTexture","winning","winningDrawWidth","winningDrawHeight","winningDrawX","winningDrawY","update","clearColor","clear","COLOR_BUFFER_BIT","setDelta","processActiveSystem","processPassiveSystem","getTouchedWorldCoord","createGameScreen","loadingBarWidth","loadingBarX","loadingBarHeight","loadingBarY","total","getTotal","currentProcess","getDone","a","EventEmitter","stage","createStage","canvas","createViewport","pixelRatio","createOrthoCamera","addCamera","Game","createGameLoop","init"],"mappings":"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","file":"static/js/main.c0698957.chunk.js","sourcesContent":["import { BitmapFont, loadAtlas, loadFont, loadTexture, Texture, TextureAtlas } from 'gdxjs';\n\nexport default class AssetManager {\n  gl: WebGLRenderingContext;\n  promises: Array<Promise<any>> = [];\n  atlases: Map<string, TextureAtlas> = new Map();\n  textures: Map<string, Texture> = new Map();\n  done = 0;\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n  }\n  loadAtlas(path: string): void {\n    const promise = loadAtlas(this.gl, path, {}).then(atlas => {\n      this.atlases.set(path, atlas);\n      this.done++;\n    });\n    this.promises.push(promise);\n  }\n  fonts: Map<string, BitmapFont> = new Map();\n  loadFont(path: string): void {\n    const promise = loadFont(this.gl, path, {}).then(font => {\n      this.fonts.set(path, font);\n      this.done++;\n    });\n    this.promises.push(promise);\n  }\n  getFont(path: string): BitmapFont | undefined {\n    return this.fonts.get(path);\n  }\n  getAtlas(path: string): TextureAtlas | undefined {\n    return this.atlases.get(path);\n  }\n  loadTexture(path: string): void {\n    const promise = loadTexture(this.gl, path, {}).then(atlas => {\n      this.textures.set(path, atlas);\n      this.done++;\n    });\n    this.promises.push(promise);\n  }\n  getTexture(path: string): Texture | undefined {\n    return this.textures.get(path);\n  }\n  async finishLoading() {\n    await Promise.all(this.promises);\n  }\n  getDone(): number {\n    return this.done;\n  }\n  getTotal(): number {\n    return this.promises.length;\n  }\n}\n","export default class Constants {\n  public static readonly CAMERA_WIDTH = 4;\n  public static readonly CAMERA_HEIGHT = 8;\n  public static readonly GAP = 1;\n  public static readonly GRAVITY = 20;\n  public static readonly PLAYER_WIDTH = 0.2;\n  public static readonly PLAYER_HEIGHT = 0.2;\n  public static readonly PLAYER_SCALE = 5;\n  public static readonly JUMP_FORCE = -10;\n  public static readonly RUN_FORCE = 2;\n  public static readonly STAR_SIZE = 0.2;\n\n  public static readonly TRANSITION_DURATION = 1.5;\n\n  public static readonly ALIEN_SPAWNING_TIME = 0.5;\n  public static readonly ALIEN_WIDTH = 1.3;\n  public static readonly ALIEN_SPEED = Constants.CAMERA_WIDTH * 1.5;\n  public static readonly ALIEN_HEIGHT = (Constants.ALIEN_WIDTH / 160) * 113;\n  public static readonly ALIEN_YS = [\n    Constants.CAMERA_HEIGHT / 2 - Constants.ALIEN_HEIGHT / 2,\n    Constants.CAMERA_WIDTH / 3 - Constants.ALIEN_HEIGHT / 2,\n    Constants.CAMERA_HEIGHT / 1.5 - Constants.ALIEN_HEIGHT / 2\n  ];\n\n  public static readonly TOTAL_BLOCK_HEIGHT = 15;\n  public static readonly BLOCK_BLOCK_SIZE = Constants.CAMERA_WIDTH * 2.1;\n  public static readonly BLOCK_SIZE = Constants.CAMERA_HEIGHT / Constants.TOTAL_BLOCK_HEIGHT;\n  public static readonly BLOCK_OFFSET_Y = Constants.CAMERA_HEIGHT / 1.7;\n}\n","import Constants from './Constants';\n\nexport default class PlayerState {\n  action: string = 'run';\n  state: string = 'A';\n  stateTime = 0;\n  states = ['A', 'B', 'B', 'C', 'C', 'D'];\n  stateIndex = 0;\n  transitionTime = 0;\n  stunnedDuration = 0;\n  appliedStun = false;\n  hp = 3;\n  score = 0;\n  complete = false;\n  getCurrentStateIndex(): number {\n    return this.stateIndex;\n  }\n  changeAction(action: string) {\n    if (action === this.action) return;\n    this.action = action;\n    this.stateTime = 0;\n  }\n  changeState(state: string) {\n    this.transitionTime = Constants.TRANSITION_DURATION;\n    this.state = state;\n  }\n  nextState() {\n    const index = this.stateIndex + 1;\n    if (index >= this.states.length) {\n      this.complete = true;\n      return;\n    }\n    this.stateIndex = index;\n    this.changeState(this.states[index]);\n  }\n  process(delta: number) {\n    this.stateTime += delta;\n    if (this.transitionTime > 0) {\n      this.transitionTime -= delta;\n    }\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { Animation, createAnimation, createBatch, OrthographicCamera, PlayMode, SpriteBatch } from 'gdxjs';\nimport Alien from '../Alien';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\n\nexport default class AlienRenderSystem extends System {\n  @Inject('aliens')\n  aliens: Array<Alien>;\n  @Inject('fixedCamera')\n  fixedCamera: OrthographicCamera;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n\n  batch: SpriteBatch;\n\n  animations: Animation[] = [];\n\n  initialized() {\n    this.batch = createBatch(this.gl);\n\n    const atlas = this.assetManager.getAtlas('./main-char.atlas');\n    if (atlas) {\n      ['alien1', 'alien2', 'alien3'].forEach(s => this.animations.push(createAnimation(0.4, atlas.findRegions(s))));\n    }\n  }\n\n  elapsed = 0;\n  process(): void {\n    this.batch.setProjection(this.fixedCamera.combined);\n    this.batch.begin();\n    this.elapsed += this.world.delta;\n    for (let alien of this.aliens) {\n      this.animations[alien.type]\n        .getKeyFrame(Constants.ALIEN_SPAWNING_TIME - alien.time, PlayMode.NORMAL)\n        .draw(this.batch, alien.x, alien.y, Constants.ALIEN_WIDTH, Constants.ALIEN_HEIGHT);\n    }\n    this.batch.end();\n  }\n}\n","import { EventEmitter } from 'events';\nimport { Inject, System } from 'flat-ecs';\nimport { Vector2 } from 'gdxjs';\nimport Alien from '../Alien';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\n\nexport default class AlienSystem extends System {\n  @Inject('aliens')\n  aliens: Array<Alien>;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  @Inject('playerState')\n  playerState: PlayerState;\n  @Inject('eventEmitter')\n  eventEmitter: EventEmitter;\n\n  process(): void {\n    for (let i = this.aliens.length - 1; i >= 0; i--) {\n      const alien = this.aliens[i];\n\n      if (alien.time > 0) {\n        alien.time -= this.world.delta;\n        return;\n      }\n\n      if (!alien.hit) {\n        const { y: py } = this.playerPos;\n        if (alien.x <= Constants.GAP && alien.x + Constants.ALIEN_WIDTH >= Constants.GAP) {\n          if (alien.y <= py && alien.y + Constants.ALIEN_HEIGHT >= py) {\n            this.playerState.stunnedDuration = 0.3;\n            this.playerState.changeAction('hurt');\n            this.playerState.hp--;\n            alien.hit = true;\n          }\n        }\n      }\n\n      alien.x -= Constants.ALIEN_SPEED * this.world.delta;\n\n      if (alien.x <= -Constants.ALIEN_WIDTH) {\n        this.aliens.splice(i, 1);\n      }\n    }\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { createBatch, OrthographicCamera, SpriteBatch, Texture, Vector2 } from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\n\nexport default class BackgroundRenderSystem extends System {\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('fixedCamera')\n  fixedCamera: OrthographicCamera;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n\n  batch: SpriteBatch;\n  textures: Map<string, Texture | undefined> = new Map();\n  initialized() {\n    this.batch = createBatch(this.gl);\n    ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n      this.textures.set(s, this.assetManager.getTexture(`./background/${s}.png`))\n    );\n  }\n  drawBackground() {\n    const bg = this.textures.get('bg') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT;\n    const drawWidth = (drawHeight / bg.height) * bg.width;\n    let i = 0;\n    while (i * drawWidth < Constants.CAMERA_WIDTH) {\n      this.batch.draw(bg, i * drawWidth, 0, drawWidth, drawHeight);\n      i++;\n    }\n  }\n  process(): void {\n    const offset = -this.playerPos.x;\n    this.batch.setProjection(this.fixedCamera.combined);\n    this.batch.begin();\n    this.drawBackground();\n    this.drawCloud1(offset * 0.5);\n    this.drawCloud2(offset * 0.8);\n    this.drawCity1(offset);\n    this.drawCity2(offset * 1.1);\n    this.batch.end();\n  }\n  drawCity1(offset: number) {\n    const city = this.textures.get('city_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.5;\n    const drawWidth = (drawHeight / city.height) * city.width;\n    while (offset <= 0) {\n      offset += drawWidth;\n    }\n    this.batch.draw(city, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(city, offset, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth;\n    }\n  }\n  drawCity2(offset: number) {\n    const city = this.textures.get('city_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.5;\n    const drawWidth = (drawHeight / city.height) * city.width;\n    while (offset <= 0) {\n      offset += drawWidth;\n    }\n    this.batch.draw(city, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(city, offset, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth;\n    }\n  }\n  drawCloud1(offset: number) {\n    const cloud = this.textures.get('cloud_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 1.2;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = drawWidth;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n  drawCloud2(offset: number) {\n    const cloud = this.textures.get('cloud_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 6;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = drawWidth;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT / 4, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT / 4, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n}\n","import { b2BodyDef, b2BodyType, b2FixtureDef, b2PolygonShape, b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\nimport { Vector2, Viewport } from 'gdxjs';\nimport Alien from '../Alien';\nimport Block from '../Block';\nimport Constants from '../Constants';\nimport Star from '../Star';\n\nconst processPattern = (s: string): number[][] => {\n  const grid: number[][] = [];\n  const blocks = s.split(';');\n  for (let block of blocks) {\n    const [xs, ys] = block.split(',');\n    let xss = xs.split('-').map(s => parseInt(s));\n    let yss = ys.split('-').map(s => parseInt(s));\n    if (xss.length === 2) {\n      const newXss = [];\n      for (let x = xss[0]; x <= xss[1]; x++) {\n        newXss.push(x);\n      }\n      xss = newXss;\n    }\n    if (yss.length === 2) {\n      const newYss = [];\n      for (let x = yss[0]; x <= yss[1]; x++) {\n        newYss.push(x);\n      }\n      yss = newYss;\n    }\n    for (let x of xss) {\n      for (let y of yss) {\n        grid.push([x, y]);\n      }\n    }\n  }\n  return grid;\n};\n\nexport default class BlockGenerationSystem extends System {\n  generatedStep = 0;\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('blocks')\n  blocks: Array<Block>;\n  @Inject('stars')\n  stars: Array<Star>;\n  @Inject('aliens')\n  aliens: Array<Alien>;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  private createBox(x: number, y: number, w: number, h: number, type: number) {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_staticBody;\n    bodyDef.position.Set(x, y);\n    const body = this.physicsWorld.CreateBody(bodyDef);\n    body.SetUserData({ type: 'block' });\n    const shape = new b2PolygonShape();\n    shape.SetAsBox(w / 2, h / 2);\n    body.CreateFixture(shape);\n\n    this.blocks.push({ x, y, w, h, type, body });\n  }\n  initialized() {\n    while (this.generatedStep < 2) {\n      this.generateBlocks(this.generatedStep * Constants.BLOCK_BLOCK_SIZE, true);\n      this.generatedStep++;\n    }\n  }\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    const currentStep = Math.floor(camPos.x / Constants.BLOCK_BLOCK_SIZE);\n    while (this.generatedStep <= currentStep + 1) {\n      this.generateBlocks(this.generatedStep * Constants.BLOCK_BLOCK_SIZE);\n      this.generatedStep++;\n    }\n  }\n\n  private createStar(x: number, y: number, special = false) {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_staticBody;\n    bodyDef.position.Set(x, y);\n    const body = this.physicsWorld.CreateBody(bodyDef);\n    body.SetUserData({ type: 'star' });\n    const fixDef = new b2FixtureDef();\n    fixDef.isSensor = true;\n    const shape = new b2PolygonShape();\n    shape.SetAsBox(Constants.STAR_SIZE, Constants.STAR_SIZE);\n    fixDef.shape = shape;\n    body.CreateFixture(fixDef);\n    const starObject = {\n      x,\n      y,\n      body,\n      active: true,\n      special\n    };\n    body.m_userData['starObject'] = starObject;\n    this.stars.push(starObject);\n  }\n\n  static patterns = [\n    '1-10,2',\n    '1-4,2;6-9,2;4,3-5;5,4;5,8-10;6,7-10;7,7-8',\n    '1-9,2;3,3-5;6-8,3;6-7,4',\n    '1-9,2;4,5-8;2,11;6,11;2-6,12;2-6,13',\n    '1-5,2;8-12,2;3-5,3;8-10,3;4-5,4;8-9,4;5-8,5;2-8,11;3-7,12;4-6,13',\n    '1-5,2;8-12,2;4-5,3;8-9,3;4-5,4;8-9,4',\n    '1-14,2;4-10,5;4-10,6;4,7;10,7;7,9-12',\n    '1-14,2;4-5,3;9-11,3;4,4;10,4;5-6,10;4-11,11;4-11,12'\n  ].map(processPattern);\n\n  static starPatterns = [\n    undefined,\n    '2.5,6.5;3,7.2;3.5,7.9;3.8,9.2;3.9,10.2;4,11.2;4.2,12.2;5.2,12.6;6.1,12.2;6.2,11.3',\n    '2.2,6.8;2.8,7.5;3.2,8.1;5.5,6.8;5.9,7.5;6.3,8.3;6.7,9.1',\n    '2.5,7.8;2.9,8.5;3.2,9.2;4,9.6;4.8,9.6;5.5,9',\n    '2.9,6.5;3.2,7.2;4,7.9;4.8,7.4;5.2,6.5;6.2,6.5;7.2,6.5;8.2,6.5',\n    '3.2,6.5;3.5,7;4,7.5;4.8,7.3;5.3,6.5;6.5,8;7,9;8,9;8.5,8;8.8,7.5;9,6.5;9.1,6',\n    '4.5,9;5.5,7.5;6.5,7.5;7.5,7.5;8.5,7.5;9.5,8;10.5,9',\n    '4.5,5.5;5.5,5.5;5.5,4.5;6.5,4.5;6.5,3.5;8.5,7.5;9,8.5;10,8.5;10.3,7.5;10.5,5.5;11.5,5.5;11.5,4.5;12.5,4.5;12.5,3.5'\n  ].map(\n    s =>\n      s &&\n      s\n        .split(';')\n        .map(s => s.split(',').map(s => parseFloat(s)))\n        .map(([x, y]) => [x - 0.5, y])\n  );\n\n  private generateBlocks(offsetX: number, first = false) {\n    const patternType = first ? 0 : Math.floor(Math.random() * (BlockGenerationSystem.patterns.length - 1)) + 1;\n    const starPattern = BlockGenerationSystem.starPatterns[patternType] || [];\n    const pattern = BlockGenerationSystem.patterns[patternType];\n    for (let cell of pattern) {\n      const [x, y] = cell;\n      this.createBox(\n        offsetX + Constants.BLOCK_SIZE * x,\n        (Constants.TOTAL_BLOCK_HEIGHT - y) * Constants.BLOCK_SIZE,\n        Constants.BLOCK_SIZE,\n        Constants.BLOCK_SIZE,\n        Math.floor(Math.random() * 3)\n      );\n    }\n    let specialGenerated = false;\n    for (let star of starPattern) {\n      const [x, y] = star;\n      const special: boolean = specialGenerated ? false : Math.random() <= 0.1;\n      if (special) specialGenerated = true;\n      this.createStar(\n        offsetX + Constants.BLOCK_SIZE * x,\n        (Constants.TOTAL_BLOCK_HEIGHT - y) * Constants.BLOCK_SIZE,\n        special\n      );\n    }\n\n    if (!first && Math.random() < 1) {\n      const type = Math.floor(Math.random() * 3);\n      this.aliens.push({\n        x: Constants.CAMERA_WIDTH - Constants.ALIEN_WIDTH,\n        y: this.playerPos.y - Constants.ALIEN_HEIGHT / 2,\n        type,\n        time: Constants.ALIEN_SPAWNING_TIME,\n        hit: false\n      });\n    }\n  }\n}\n","import { b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\nimport { Viewport } from 'gdxjs';\nimport Block from '../Block';\nimport Constants from '../Constants';\nimport Star from '../Star';\n\nexport default class BlockRemovalSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('blocks')\n  blocks: Array<Block>;\n  @Inject('stars')\n  stars: Array<Star>;\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    for (let i = this.blocks.length - 1; i >= 0; i--) {\n      const block = this.blocks[i];\n      if (camPos.x - block.x >= 3 * Constants.CAMERA_WIDTH) {\n        this.physicsWorld.DestroyBody(block.body);\n        this.blocks.splice(i, 1);\n      }\n    }\n    for (let i = this.stars.length - 1; i >= 0; i--) {\n      const star = this.stars[i];\n      if (camPos.x - star.x >= 3 * Constants.CAMERA_WIDTH) {\n        this.physicsWorld.DestroyBody(star.body);\n        this.stars.splice(i, 1);\n      }\n    }\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { createBatch, createWhiteTexture, SpriteBatch, Texture, TextureAtlas, TextureRegion, Viewport } from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Block from '../Block';\n\nexport default class BlockRenderSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('blocks')\n  blocks: Array<Block>;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n\n  batch: SpriteBatch;\n  whiteTex: Texture;\n  atlas: TextureAtlas;\n  regions: TextureRegion[];\n  initialized() {\n    this.batch = createBatch(this.gl);\n    this.whiteTex = createWhiteTexture(this.gl);\n    const atlas = this.assetManager.getAtlas('./ground.atlas');\n    if (atlas) {\n      this.atlas = atlas;\n      this.regions = atlas.findRegions('tile');\n    }\n  }\n  process(): void {\n    this.batch.setProjection(this.viewport.getCamera().combined);\n    this.batch.begin();\n    for (let box of this.blocks) {\n      const { x, y, w, h, type } = box;\n      this.regions[type].draw(this.batch, x - w / 2, y - h / 2, w, h);\n    }\n    this.batch.end();\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { Vector2, Viewport } from 'gdxjs';\nimport Constants from '../Constants';\n\nexport default class CameraMovementSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  process(): void {\n    const camPos = this.viewport.getCamera().getPosition();\n    this.viewport.getCamera().setPosition(this.playerPos.x - Constants.GAP, camPos.y);\n  }\n}\n","import { b2World } from 'box2d.ts';\nimport { Inject, System } from 'flat-ecs';\n\nexport default class PhysicsSystem extends System {\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  process(): void {\n    this.physicsWorld.Step(this.world.delta, 8, 3);\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport {\n  AlignMode,\n  BitmapFont,\n  createBatch,\n  createWhiteTexture,\n  OrthographicCamera,\n  SpriteBatch,\n  TextRenderer,\n  Texture,\n  TextureAtlas,\n  TextureRegion\n} from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\n\nexport const padNumber = (number: number, length: number): string => {\n  let result = `${number}`;\n  while (result.length < length) {\n    result = `0${result}`;\n  }\n  return result;\n};\n\nexport default class UISystem extends System {\n  @Inject('fixedCamera')\n  fixedCamera: OrthographicCamera;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('playerState')\n  playerState: PlayerState;\n  batch: SpriteBatch;\n\n  panel: TextureRegion;\n  heartFull: TextureRegion;\n  heartEmpty: TextureRegion;\n  bar: TextureRegion;\n  scoreLabel: TextureRegion;\n  text: TextRenderer;\n  whiteText: Texture;\n  initialized() {\n    this.batch = createBatch(this.gl);\n    const atlas = this.assetManager.getAtlas('./ui.atlas') as TextureAtlas;\n    this.panel = atlas.findRegions('panel')[0];\n    this.heartFull = atlas.findRegions('heart-full')[0];\n    this.heartEmpty = atlas.findRegions('heart-empty')[0];\n    this.bar = atlas.findRegions('bar')[0];\n    this.scoreLabel = atlas.findRegions('score-label')[0];\n    const font = this.assetManager.getFont('./score.fnt') as BitmapFont;\n    this.text = font.createRenderer(Constants.CAMERA_WIDTH * 0.35);\n    this.text.setAlignMode(AlignMode.right);\n    this.whiteText = createWhiteTexture(this.gl);\n  }\n  process(): void {\n    this.batch.setProjection(this.fixedCamera.combined);\n    this.batch.begin();\n\n    const { width: panelWidth, height: panelHeight } = this.panel;\n    const panelDrawWidth = Constants.CAMERA_WIDTH * 0.95;\n    const panelDrawHeight = (panelDrawWidth / panelWidth) * panelHeight;\n    const panelDrawX = Constants.CAMERA_WIDTH * 0.025;\n    const panelDrawY = Constants.CAMERA_WIDTH * 0.05;\n    this.panel.draw(this.batch, panelDrawX, panelDrawY, panelDrawWidth, panelDrawHeight);\n\n    const { width: heartWidth, height: heartHeight } = this.heartFull;\n    const heartDrawWidth = panelDrawWidth / 26;\n    const heartDrawHeight = (heartDrawWidth / heartWidth) * heartHeight;\n    const heartStartX = 2 * heartDrawWidth;\n    const heartStartY = panelDrawY + panelDrawHeight - 1.75 * heartDrawHeight;\n    const heartGap = heartDrawWidth * 0.2;\n    for (let i = 0; i < 3; i++) {\n      if (i < this.playerState.hp) {\n        this.heartFull.draw(\n          this.batch,\n          heartStartX + (heartDrawWidth + heartGap) * i,\n          heartStartY,\n          heartDrawWidth,\n          heartDrawHeight\n        );\n      } else {\n        this.heartEmpty.draw(\n          this.batch,\n          heartStartX + (heartDrawWidth + heartGap) * i,\n          heartStartY,\n          heartDrawWidth,\n          heartDrawHeight\n        );\n      }\n    }\n\n    const { width: barWidth, height: barHeight } = this.bar;\n    const barDrawX = heartStartX;\n    const barDrawWidth = panelDrawWidth - 2 * (barDrawX - panelDrawX);\n    const barDrawHeight = (barDrawWidth / barWidth) * barHeight;\n    const barDrawY = panelDrawY + panelDrawHeight / 1.7 - barDrawHeight;\n    this.bar.draw(this.batch, barDrawX, barDrawY, barDrawWidth, barDrawHeight);\n\n    const { width: scoreLabelWidth, height: scoreLabelHeight } = this.scoreLabel;\n    const scoreDrawHeight = heartDrawHeight * 0.8;\n    const scoreDrawWidth = (scoreDrawHeight / scoreLabelHeight) * scoreLabelWidth;\n    const scoreDrawY = heartStartY + heartDrawHeight - scoreDrawHeight;\n    const scoreDrawX = heartStartX + 10 * heartDrawWidth;\n    this.scoreLabel.draw(this.batch, scoreDrawX, scoreDrawY, scoreDrawWidth, scoreDrawHeight);\n\n    const fontSize = heartDrawHeight * 1.35;\n    const textDrawY = scoreDrawY + scoreDrawHeight - fontSize;\n\n    this.text.setDisplayWidth(panelDrawWidth - 3 * heartDrawWidth);\n    this.text.draw(this.batch, padNumber(this.playerState.score, 10), panelDrawX, textDrawY, fontSize);\n\n    const coverStartX = barDrawX;\n    const coverGap = barDrawWidth / 250;\n    const coverWidth = barDrawWidth / 6 - coverGap;\n    const coverStartY = barDrawY + barDrawHeight;\n    this.batch.setColor(0, 0, 0, 1);\n    for (let i = 0; i < 6; i++) {\n      if (i >= this.playerState.stateIndex) {\n        const coverHeight = barDrawHeight * (1 - (5 - i) * 0.12);\n        this.batch.draw(\n          this.whiteText,\n          coverStartX + i * (coverGap + coverWidth),\n          coverStartY - coverHeight,\n          coverWidth,\n          coverHeight\n        );\n      }\n    }\n    this.batch.setColor(1, 1, 1, 1);\n    this.batch.end();\n  }\n}\n","import {\n  b2Body,\n  b2BodyDef,\n  b2BodyType,\n  b2CircleShape,\n  b2Contact,\n  b2ContactListener,\n  b2FixtureDef,\n  b2PolygonShape,\n  b2World\n} from 'box2d.ts';\nimport { EventEmitter } from 'fbemitter';\nimport { Inject, System } from 'flat-ecs';\nimport { Vector2 } from 'gdxjs';\nimport { ViewportAwareInputHandler } from 'gdxjs/lib/createViewportAwareInputHandler';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\nimport { padNumber } from './UISystem';\n\nexport default class PlayerMovementSystem extends System {\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  @Inject('inputHandler')\n  inputHandler: ViewportAwareInputHandler;\n  @Inject('playerState')\n  playerState: PlayerState;\n  @Inject('eventEmitter')\n  eventEmitter: EventEmitter;\n  playerBody: b2Body;\n  initialized() {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_dynamicBody;\n    bodyDef.fixedRotation = true;\n    bodyDef.position.Set(2, Constants.CAMERA_HEIGHT / 2);\n    const body = this.physicsWorld.CreateBody(bodyDef);\n    body.SetUserData({\n      type: 'user'\n    });\n    const shape = new b2CircleShape(Constants.PLAYER_WIDTH);\n    shape.Set({ x: -Constants.PLAYER_WIDTH / 2, y: -Constants.PLAYER_HEIGHT / 2 }, Constants.PLAYER_WIDTH);\n    body.CreateFixture(shape);\n\n    const sensorShape = new b2PolygonShape();\n    sensorShape.SetAsBox(Constants.PLAYER_WIDTH / 8, Constants.PLAYER_WIDTH / 8, {\n      x: 0,\n      y: Constants.PLAYER_HEIGHT / 2\n    });\n    const fixDef = new b2FixtureDef();\n    fixDef.isSensor = true;\n    fixDef.shape = sensorShape;\n    fixDef.userData = { type: 'playerSensor' };\n\n    body.CreateFixture(fixDef);\n\n    const sensorShape2 = new b2PolygonShape();\n    sensorShape2.SetAsBox(Constants.PLAYER_WIDTH / 8, Constants.PLAYER_WIDTH / 8, {\n      x: Constants.PLAYER_WIDTH / 2,\n      y: 0\n    });\n    const fixDef2 = new b2FixtureDef();\n    fixDef2.isSensor = true;\n    fixDef2.shape = sensorShape2;\n    fixDef2.userData = { type: 'playerSensor2' };\n\n    body.CreateFixture(fixDef2);\n\n    this.playerBody = body;\n\n    class ContactListener extends b2ContactListener {\n      movementSytem: PlayerMovementSystem;\n      constructor(movementSystem: PlayerMovementSystem) {\n        super();\n        this.movementSytem = movementSystem;\n      }\n      processJumpable(contact: b2Contact): void {\n        let otherFixture;\n\n        const fixA = contact.GetFixtureA();\n        const fixB = contact.GetFixtureB();\n\n        if (fixA.IsSensor() && fixA.GetUserData()?.type === 'playerSensor') {\n          otherFixture = fixB;\n        } else if (fixB.IsSensor() && fixB.GetUserData()?.type === 'playerSensor') {\n          otherFixture = fixA;\n        }\n\n        if (otherFixture && otherFixture.GetBody().GetUserData()?.type === 'block') {\n          this.movementSytem.jumpLeft = 2;\n          this.movementSytem.playerState.changeAction('run');\n        }\n      }\n      processObstacle(contact: b2Contact): void {\n        let otherFixture;\n\n        const fixA = contact.GetFixtureA();\n        const fixB = contact.GetFixtureB();\n\n        if (fixA.IsSensor() && fixA.GetUserData()?.type === 'playerSensor2') {\n          otherFixture = fixB;\n        } else if (fixB.IsSensor() && fixB.GetUserData()?.type === 'playerSensor2') {\n          otherFixture = fixA;\n        }\n\n        if (otherFixture && otherFixture.GetBody().GetUserData()?.type === 'block') {\n          this.movementSytem.playerState.stunnedDuration = 0.2;\n          this.movementSytem.playerState.changeAction('hurt');\n        }\n      }\n      BeginContact(contact: b2Contact): void {\n        if (this.movementSytem.gameOver) return;\n        this.processJumpable(contact);\n        this.processObstacle(contact);\n        this.movementSytem.eventEmitter.emit('beginContact', contact);\n      }\n    }\n    this.physicsWorld.SetContactListener(new ContactListener(this));\n  }\n  pressed = false;\n  jumpLeft = 0;\n  gameOver = false;\n  zeroCenter = { x: 0, y: 0 };\n  runImpulse = { x: Constants.RUN_FORCE, y: 0 };\n  jumpImpulse = { x: 0, y: Constants.JUMP_FORCE };\n  process(): void {\n    if (this.playerState.stunnedDuration > 0) {\n      if (!this.playerState.appliedStun) {\n        this.playerState.appliedStun = true;\n        this.playerBody.GetLinearVelocity().Set(0, 0);\n        this.playerBody.ApplyLinearImpulse({ x: -2 * Constants.RUN_FORCE, y: 0 }, { x: 0, y: 0 });\n      }\n      this.playerState.stunnedDuration -= this.world.delta;\n      if (this.playerState.stunnedDuration <= 0) {\n        this.playerState.changeAction('run');\n        this.playerState.appliedStun = false;\n      }\n    } else {\n      const v = this.playerBody.GetLinearVelocity();\n      v.Set(0, v.y);\n      this.playerBody.ApplyLinearImpulse(this.runImpulse, this.zeroCenter);\n\n      if (this.pressed) {\n        if (!this.inputHandler.isTouched()) {\n          this.pressed = false;\n        }\n      } else {\n        if (this.inputHandler.isTouched() && this.jumpLeft > 0) {\n          this.jumpLeft--;\n          if (this.jumpLeft === 1) {\n            this.playerState.changeAction('jump');\n          } else {\n            this.playerState.changeAction('doubleJump');\n          }\n          this.pressed = true;\n          const v = this.playerBody.GetLinearVelocity();\n          v.Set(v.x, 0);\n          this.playerBody.ApplyLinearImpulse(this.jumpImpulse, this.zeroCenter);\n        }\n      }\n    }\n    const bodyPos = this.playerBody.GetPosition();\n    this.playerPos.set(bodyPos.x, bodyPos.y);\n\n    if (\n      !this.gameOver &&\n      (bodyPos.y > Constants.CAMERA_HEIGHT * 1.2 || this.playerState.hp <= 0 || this.playerState.complete)\n    ) {\n      this.gameOver = true;\n      this.eventEmitter.emit('gameOver', padNumber(this.playerState.score, 10));\n    }\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport {\n  createAnimation,\n  createBatch,\n  createWhiteTexture,\n  SpriteBatch,\n  Texture,\n  TextureAtlas,\n  Vector2,\n  Viewport,\n  Animation,\n  PlayMode,\n  TextureRegion\n} from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\n\nexport default class PlayerRenderSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('playerState')\n  playerState: PlayerState;\n  batch: SpriteBatch;\n  whiteTex: Texture;\n  atlas: TextureAtlas;\n  animations: any = {};\n  initialized() {\n    this.batch = createBatch(this.gl);\n    this.whiteTex = createWhiteTexture(this.gl);\n\n    const atlas = this.assetManager.getAtlas('./main-char.atlas');\n    if (atlas) {\n      this.atlas = atlas;\n      this.animations['upgrade'] = createAnimation(0.08, atlas.findRegions('upgrade_blast'));\n    }\n  }\n  animationFrameDuration: any = {\n    run: 0.1,\n    jump: 0.1,\n    doubleJump: 0.1,\n    hurt: 0.05\n  };\n  getAnimation(action: string, state: string): Animation {\n    const animName = `${action}${state}`;\n    if (!this.animations[animName]) {\n      const frameDuration: number = this.animationFrameDuration[action] || 0.1;\n      let frames = this.atlas.findRegions(animName);\n      if (action === 'jump' || action === 'doubleJump') {\n        frames = frames.slice(0, frames.length - 2) as [TextureRegion];\n      }\n      this.animations[animName] = createAnimation(frameDuration, frames);\n    }\n    return this.animations[animName];\n  }\n  process(): void {\n    this.batch.setProjection(this.viewport.getCamera().combined);\n    this.batch.begin();\n    const { x, y } = this.playerPos;\n    this.playerState.process(this.world.delta);\n\n    let playMode = PlayMode.LOOP;\n    if (this.playerState.action === 'jump' || this.playerState.action === 'doubleJump') {\n      playMode = PlayMode.NORMAL;\n    }\n\n    const animation = this.getAnimation(this.playerState.action, this.playerState.state);\n    animation\n      .getKeyFrame(this.playerState.stateTime, playMode)\n      .draw(\n        this.batch,\n        x - Constants.PLAYER_WIDTH / 2,\n        y - Constants.PLAYER_HEIGHT / 2,\n        Constants.PLAYER_WIDTH,\n        Constants.PLAYER_HEIGHT,\n        Constants.PLAYER_WIDTH / 2,\n        Constants.PLAYER_HEIGHT,\n        0,\n        Constants.PLAYER_SCALE,\n        Constants.PLAYER_SCALE\n      );\n\n    if (this.playerState.transitionTime > 0) {\n      const blast = this.animations['upgrade'] as Animation;\n      blast\n        .getKeyFrame(this.playerState.stateTime, PlayMode.LOOP)\n        .draw(\n          this.batch,\n          x - Constants.PLAYER_WIDTH / 2,\n          y,\n          Constants.PLAYER_WIDTH,\n          Constants.PLAYER_HEIGHT,\n          Constants.PLAYER_WIDTH / 2,\n          Constants.PLAYER_HEIGHT,\n          0,\n          Constants.PLAYER_SCALE * 1.2,\n          Constants.PLAYER_SCALE * 1.2\n        );\n    }\n    this.batch.end();\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport { createBatch, OrthographicCamera, SpriteBatch, Texture, Vector2 } from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\n\nexport default class SmokeRenderSystem extends System {\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('fixedCamera')\n  fixedCamera: OrthographicCamera;\n  @Inject('playerPosition')\n  playerPos: Vector2;\n\n  batch: SpriteBatch;\n  textures: Map<string, Texture | undefined> = new Map();\n  initialized() {\n    this.batch = createBatch(this.gl);\n    ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n      this.textures.set(s, this.assetManager.getTexture(`./background/${s}.png`))\n    );\n  }\n  process(): void {\n    const offset = -this.playerPos.x;\n    this.batch.setProjection(this.fixedCamera.combined);\n    this.batch.begin();\n    this.drawCloud1(offset * 0.6);\n    this.drawCloud2(offset * 0.1);\n    this.batch.end();\n  }\n  drawCloud1(offset: number) {\n    const cloud = this.textures.get('smoke_01') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 5;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = -drawWidth / 1.5;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n  drawCloud2(offset: number) {\n    const cloud = this.textures.get('smoke_02') as Texture;\n    const drawHeight = Constants.CAMERA_HEIGHT / 5;\n    const drawWidth = (drawHeight / cloud.height) * cloud.width;\n    const gap = -drawWidth / 1.5;\n    while (offset <= 0) {\n      offset += drawWidth + gap;\n    }\n    this.batch.draw(cloud, offset - drawWidth, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n    while (offset + gap <= Constants.CAMERA_WIDTH) {\n      this.batch.draw(cloud, offset + gap, Constants.CAMERA_HEIGHT - drawHeight / 2, drawWidth, drawHeight);\n      offset += drawWidth + gap;\n    }\n  }\n}\n","import { b2Contact, b2World } from 'box2d.ts';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport { Inject, System } from 'flat-ecs';\nimport PlayerState from '../PlayerState';\nimport Star from '../Star';\n\nexport default class StarCollisionSystem extends System {\n  @Inject('physicsWorld')\n  physicsWorld: b2World;\n  @Inject('stars')\n  stars: Array<Star>;\n  @Inject('eventEmitter')\n  eventEmitter: EventEmitter;\n  @Inject('playerState')\n  playerState: PlayerState;\n  subscription: EventSubscription;\n  initialized() {\n    this.subscription = this.eventEmitter.addListener('beginContact', (contact: b2Contact) => {\n      let otherFixture, starFixture;\n      const fixA = contact.GetFixtureA();\n      const fixB = contact.GetFixtureB();\n      if (fixA.GetBody().GetUserData()?.type === 'star') {\n        otherFixture = fixB;\n        starFixture = fixA;\n      } else if (fixA.GetBody().GetUserData()?.type === 'star') {\n        otherFixture = fixA;\n        starFixture = fixB;\n      }\n      if (starFixture && otherFixture && otherFixture.GetBody().GetUserData()?.type === 'user') {\n        this.removeStar(starFixture.GetBody().GetUserData().starObject);\n      }\n    });\n  }\n  process(): void {}\n  removeStar(starObject: any) {\n    if (!starObject.active) {\n      return;\n    }\n    if (starObject.special) {\n      this.playerState.nextState();\n    } else {\n      this.playerState.score += 100 * (this.playerState.stateIndex + 1);\n    }\n    starObject.active = false;\n  }\n  dispose() {\n    this.subscription.remove();\n  }\n}\n","import { Inject, System } from 'flat-ecs';\nimport {\n  Animation,\n  createAnimation,\n  createBatch,\n  createWhiteTexture,\n  PlayMode,\n  SpriteBatch,\n  Texture,\n  Viewport\n} from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\nimport Star from '../Star';\n\nexport default class StarRenderSystem extends System {\n  @Inject('viewport')\n  viewport: Viewport;\n  @Inject('context')\n  gl: WebGLRenderingContext;\n  @Inject('stars')\n  stars: Array<Star>;\n  @Inject('assetManager')\n  assetManager: AssetManager;\n  @Inject('playerState')\n  playerState: PlayerState;\n\n  batch: SpriteBatch;\n  whiteTex: Texture;\n  starAnimation: Animation;\n  specialAnimations: Animation[];\n\n  initialized() {\n    this.batch = createBatch(this.gl);\n    this.whiteTex = createWhiteTexture(this.gl);\n    const atlas = this.assetManager.getAtlas('./object.atlas');\n    if (atlas) {\n      this.starAnimation = createAnimation(0.2, atlas.findRegions('star'));\n      this.specialAnimations = ['hand', 'hand', 'feet', 'feet', 'chest', 'head'].map(s =>\n        createAnimation(0.2, atlas.findRegions(s))\n      );\n    }\n  }\n  elapsed = 0;\n  process(): void {\n    this.batch.setProjection(this.viewport.getCamera().combined);\n    this.batch.begin();\n    this.elapsed += this.world.delta;\n    for (let star of this.stars) {\n      const { x, y, active, special } = star;\n      if (!active) continue;\n      if (special) {\n        this.specialAnimations[this.playerState.getCurrentStateIndex()]\n          .getKeyFrame(this.elapsed, PlayMode.LOOP)\n          .draw(\n            this.batch,\n            x - Constants.STAR_SIZE / 2,\n            y - Constants.STAR_SIZE / 2,\n            Constants.STAR_SIZE,\n            Constants.STAR_SIZE,\n            Constants.STAR_SIZE / 2,\n            Constants.STAR_SIZE / 2,\n            0,\n            2,\n            2\n          );\n      } else {\n        this.starAnimation\n          .getKeyFrame(this.elapsed, PlayMode.LOOP)\n          .draw(\n            this.batch,\n            x - Constants.STAR_SIZE / 2,\n            y - Constants.STAR_SIZE / 2,\n            Constants.STAR_SIZE,\n            Constants.STAR_SIZE\n          );\n      }\n    }\n    this.batch.end();\n  }\n}\n","import { EventEmitter } from 'fbemitter';\nimport { createBatch, createWhiteTexture, Game, OrthographicCamera, Screen, Viewport } from 'gdxjs';\nimport AssetManager from '../AssetManager';\nimport Constants from '../Constants';\nimport createGameScreen from './createGameScreen';\n\nexport default function createLoadingScreen(\n  game: Game<any>,\n  viewport: Viewport,\n  assetManager: AssetManager,\n  fixedCamera: OrthographicCamera,\n  eventEmitter: EventEmitter\n): Screen<any> {\n  const gl = viewport.getContext();\n  assetManager.loadAtlas('./main-char.atlas');\n  assetManager.loadAtlas('./ground.atlas');\n  assetManager.loadAtlas('./object.atlas');\n  ['bg', 'city_01', 'city_02', 'cloud_01', 'cloud_02', 'smoke_01', 'smoke_02'].map(s =>\n    assetManager.loadTexture(`./background/${s}.png`)\n  );\n  assetManager.loadAtlas('./ui.atlas');\n  assetManager.loadFont('./score.fnt');\n  assetManager.loadTexture('./winning.png');\n  assetManager.finishLoading().then(() => {\n    setTimeout(() => {\n      game.setScreen(createGameScreen(viewport, assetManager, fixedCamera, eventEmitter));\n    }, 1000);\n  });\n\n  const batch = createBatch(gl);\n  const whiteTex = createWhiteTexture(gl);\n  const loadingBarWidth = Constants.CAMERA_WIDTH * 0.8;\n  const loadingBarX = Constants.CAMERA_WIDTH * 0.1;\n  const loadingBarHeight = loadingBarWidth / 40;\n  const loadingBarY = (Constants.CAMERA_HEIGHT - loadingBarHeight) / 2;\n\n  const total = assetManager.getTotal();\n  let currentProcess = 0;\n\n  return {\n    update(delta) {\n      gl.clearColor(0.694, 0.173, 0.192, 1);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      const done = assetManager.getDone();\n      const realProcess = done / total;\n      currentProcess = currentProcess + (realProcess - currentProcess) * 0.05;\n\n      batch.setProjection(fixedCamera.combined);\n      batch.begin();\n      batch.draw(whiteTex, loadingBarX, loadingBarY, loadingBarWidth * currentProcess, loadingBarHeight);\n      batch.end();\n    }\n  };\n}\n","import { b2World } from 'box2d.ts';\nimport { World } from 'flat-ecs';\nimport {\n  AlignMode,\n  BitmapFont,\n  createBatch,\n  createViewportAwareInputHandler,\n  createWhiteTexture,\n  OrthographicCamera,\n  Screen,\n  Texture,\n  Vector2,\n  Viewport\n} from 'gdxjs';\nimport Alien from '../Alien';\nimport AssetManager from '../AssetManager';\nimport Block from '../Block';\nimport Constants from '../Constants';\nimport PlayerState from '../PlayerState';\nimport Star from '../Star';\nimport { EventEmitter } from 'fbemitter';\nimport AlienRenderSystem from '../systems/AlienRenderSystem';\nimport AlienSystem from '../systems/AlienSystem';\nimport BackgroundRenderSystem from '../systems/BackgroundRenderSystem';\nimport BlockGenerationSystem from '../systems/BlockGenerationSystem';\nimport BlockRemovalSystem from '../systems/BlockRemovalSystem';\nimport BlockRenderSystem from '../systems/BlockRenderSystem';\nimport CameraMovementSystem from '../systems/CameraMovementSystem';\nimport PhysicsSystem from '../systems/PhysicsSystem';\nimport PlayerMovementSystem from '../systems/PlayerMovementSystem';\nimport PlayerRenderSystem from '../systems/PlayerRenderSystem';\nimport SmokeRenderSystem from '../systems/SmokeRenderSystem';\nimport StarCollisionSystem from '../systems/StarCollisionSystem';\nimport StarRenderSystem from '../systems/StarRenderSystem';\nimport UISystem from '../systems/UISystem';\n\nexport default function createGameScreen(\n  viewport: Viewport,\n  assetManager: AssetManager,\n  fixedCamera: OrthographicCamera,\n  eventEmitter: EventEmitter\n): Screen<any> {\n  const gl = viewport.getContext();\n  const inputHandler = createViewportAwareInputHandler(viewport.getCanvas(), viewport);\n\n  const createNewWorld = () => {\n    const blocks: Array<Block> = [];\n    const stars: Array<Star> = [];\n    const aliens: Array<Alien> = [];\n    const physicsWorld = new b2World({ x: 0, y: Constants.GRAVITY });\n    const gameWorld = new World();\n    const playerState = new PlayerState();\n    const playerPosition = new Vector2(0, 0);\n    viewport.getCamera().setPosition(0, 0);\n\n    gameWorld.register('context', gl);\n    gameWorld.register('physicsWorld', physicsWorld);\n    gameWorld.register('viewport', viewport);\n    gameWorld.register('blocks', blocks);\n    gameWorld.register('stars', stars);\n    gameWorld.register('aliens', aliens);\n    gameWorld.register('playerPosition', playerPosition);\n    gameWorld.register('inputHandler', inputHandler);\n    gameWorld.register('assetManager', assetManager);\n    gameWorld.register('playerState', playerState);\n    gameWorld.register('fixedCamera', fixedCamera);\n    gameWorld.register('eventEmitter', eventEmitter);\n\n    gameWorld.addSystem(new BlockGenerationSystem());\n    gameWorld.addSystem(new PlayerMovementSystem());\n    gameWorld.addSystem(new BlockRemovalSystem());\n    gameWorld.addSystem(new StarCollisionSystem());\n    gameWorld.addSystem(new AlienSystem());\n    gameWorld.addSystem(new PhysicsSystem());\n\n    gameWorld.addSystem(new CameraMovementSystem(), false);\n    gameWorld.addSystem(new BackgroundRenderSystem(), false);\n    gameWorld.addSystem(new BlockRenderSystem(), false);\n    gameWorld.addSystem(new StarRenderSystem(), false);\n    gameWorld.addSystem(new AlienRenderSystem(), false);\n    gameWorld.addSystem(new PlayerRenderSystem(), false);\n    gameWorld.addSystem(new SmokeRenderSystem(), false);\n    gameWorld.addSystem(new UISystem(), false);\n    return gameWorld;\n  };\n\n  let gameWorld = createNewWorld();\n  let gameOver = false;\n  let result = '';\n\n  eventEmitter.addListener('gameOver', (score: string) => {\n    gameOver = true;\n    gameWorld.dispose();\n    result = score;\n  });\n\n  const batch = createBatch(gl);\n  const whiteTexture = createWhiteTexture(gl);\n  const winning = assetManager.getTexture('./winning.png') as Texture;\n  const winningDrawWidth = Constants.CAMERA_WIDTH * 0.8;\n  const winningDrawHeight = (winningDrawWidth / winning.width) * winning.height;\n  const winningDrawX = Constants.CAMERA_WIDTH * 0.1;\n  const winningDrawY = (Constants.CAMERA_HEIGHT - winningDrawHeight) / 2;\n\n  const font = assetManager.getFont('./score.fnt') as BitmapFont;\n  const text = font.createRenderer(winningDrawWidth * 0.9);\n  text.setAlignMode(AlignMode.right);\n  const fontSize = winningDrawHeight / 20;\n\n  const update = (delta: number) => {\n    gl.clearColor(0, 0, 0, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gameWorld.setDelta(delta);\n    !gameOver && gameWorld.processActiveSystem();\n    gameWorld.processPassiveSystem();\n\n    if (gameOver) {\n      batch.setProjection(fixedCamera.combined);\n      batch.begin();\n      batch.setColor(0, 0, 0, 0.75);\n      batch.draw(whiteTexture, 0, 0, Constants.CAMERA_WIDTH, Constants.CAMERA_HEIGHT);\n      batch.setColor(1, 1, 1, 1);\n      batch.draw(winning, winningDrawX, winningDrawY, winningDrawWidth, winningDrawHeight);\n      text.setColor(1, 0, 0, 1);\n      text.draw(batch, result, winningDrawX, winningDrawY + winningDrawHeight / 1.48, fontSize);\n      text.setColor(1, 1, 1, 1);\n      text.draw(batch, result, winningDrawX, winningDrawY + winningDrawHeight / 1.49, fontSize);\n      batch.end();\n      if (inputHandler.isTouched()) {\n        const { y } = inputHandler.getTouchedWorldCoord();\n        if (y >= winningDrawY + winningDrawHeight * 0.8 && y < winningDrawY + winningDrawHeight) {\n          gameWorld = createNewWorld();\n          gameOver = false;\n        }\n      }\n    }\n  };\n  return { update };\n}\n","import { EventEmitter } from 'fbemitter';\nimport { createGameLoop, createOrthoCamera, createStage, createViewport, Game } from 'gdxjs';\nimport AssetManager from './AssetManager';\nimport Constants from './Constants';\nimport './index.css';\nimport createLoadingScreen from './screens/createLoadingScreen';\n\nconst init = async () => {\n  const eventEmitter = new EventEmitter();\n  const stage = createStage();\n  const canvas = stage.getCanvas();\n\n  const viewport = createViewport(canvas, Constants.CAMERA_WIDTH, Constants.CAMERA_HEIGHT, {\n    pixelRatio: 1\n  });\n  const gl = viewport.getContext();\n\n  const fixedCamera = createOrthoCamera(Constants.CAMERA_WIDTH, Constants.CAMERA_HEIGHT, canvas.width, canvas.height);\n  viewport.addCamera(fixedCamera);\n  viewport.update();\n\n  const assetManager = new AssetManager(gl);\n\n  const game = new Game();\n  game.setScreen(createLoadingScreen(game, viewport, assetManager, fixedCamera, eventEmitter));\n\n  createGameLoop(delta => {\n    game.update(delta, {});\n  });\n};\n\ninit();\n"],"sourceRoot":""}